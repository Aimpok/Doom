<!DOCTYPE html>
<html>
<head>
    <title>3D Лабиринт - Мультиплеер</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <style>
        body { 
            margin: 0; 
            padding: 0; 
            overflow: hidden;
            font-family: Arial, sans-serif;
            touch-action: none;
            -webkit-touch-callout: none;
            -webkit-user-select: none;
            user-select: none;
            background: #000;
        }
        canvas { 
            display: block; 
            touch-action: none;
        }
        
        /* Стартовое меню в стиле DOOM */
        #startMenu {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #000;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 100;
            background-image: url('MenuUi/MenuBg.png');
            background-size: cover;
            background-position: center;
            background-repeat: no-repeat;
        }
        
        .logo {
            width: 55vmin;
            max-width: 800px;
            position: absolute;
            top: 20%;
            transform: translateY(-50%);
            object-fit: contain;
            -webkit-user-drag: none;
            user-drag: none;
            pointer-events: none;
            -webkit-touch-callout: none;
        }
        
        .menu-buttons {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 2.4vmin;
            position: absolute;
            top: 60%;
            transform: translateY(-50%);
        }
        
        .menu-button {
            width: 60vmin;
            max-width: 600px;
            min-width: 250px;
            cursor: pointer;
            transition: all 0.3s ease;
            object-fit: contain;
            -webkit-user-drag: none;
            user-drag: none;
            pointer-events: auto;
            -webkit-touch-callout: none;
            -webkit-tap-highlight-color: transparent;
        }
        
        .menu-button:hover {
            transform: scale(1.05);
        }
        
        .menu-button:active {
            transform: scale(1.02);
        }
        
        .company-name {
            position: absolute;
            bottom: 0vmin;
            width: 28vmin;
            max-width: 300px;
            object-fit: contain;
            -webkit-user-drag: none;
            user-drag: none;
            pointer-events: none;
            opacity: 0.8;
            -webkit-touch-callout: none;
        }

        /* Панель подключения к комнате */
        #connectMenu {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-image: url('MenuUi/MenuBg.png');
            background-size: cover;
            background-position: center;
            background-repeat: no-repeat;
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 120;
            color: #fff;
        }
        
        .connect-title {
            width: 60vmin;
            max-width: 600px;
            min-width: 250px;
            margin-bottom: 5vmin;
            object-fit: contain;
            -webkit-user-drag: none;
            user-drag: none;
            pointer-events: none;
        }
        
        .connect-input {
            margin: 2vmin 0;
            font-size: 3vmin;
            color: #fff;
            background: rgba(0, 0, 0, 0.7);
            padding: 1vmin 2vmin;
            border-radius: 5px;
            width: 80%;
            max-width: 400px;
            border: 2px solid #fff;
            text-align: center;
        }
        
        .connect-input::placeholder {
            color: #ccc;
        }
        
        .connect-buttons {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 2vmin;
            margin-top: 3vmin;
        }

        /* Экран настроек */
        #optionsMenu {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-image: url('MenuUi/MenuBg.png');
            background-size: cover;
            background-position: center;
            background-repeat: no-repeat;
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 150;
            color: #fff;
        }
        
        .options-title {
            width: 60vmin;
            max-width: 600px;
            min-width: 250px;
            margin-bottom: 5vmin;
            object-fit: contain;
            -webkit-user-drag: none;
            user-drag: none;
            pointer-events: none;
        }
        
        .option-item {
            margin: 2vmin 0;
            font-size: 3vmin;
            color: #fff;
            background: rgba(0, 0, 0, 0.7);
            padding: 1vmin 2vmin;
            border-radius: 5px;
            width: 80%;
            max-width: 400px;
        }
        
        .option-item label {
            display: flex;
            flex-direction: column;
            gap: 1vmin;
            width: 100%;
        }
        
        .back-button {
            margin-top: 5vmin;
            width: 60vmin;
            max-width: 600px;
            min-width: 250px;
            cursor: pointer;
            transition: all 0.3s ease;
            object-fit: contain;
            -webkit-user-drag: none;
            user-drag: none;
            pointer-events: auto;
            -webkit-touch-callout: none;
        }
        
        .back-button:hover {
            transform: scale(1.05);
        }
        
        /* Мобильное управление */
        #mobileControls {
            position: absolute;
            bottom: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 50;
            display: none;
        }
        
        /* Джойстик для движения - УМЕНЬШЕН */
        #movementJoystick {
            position: absolute;
            bottom: 5vmin;
            left: 5vmin;
            width: 30vmin;
            height: 30vmin;
            pointer-events: auto;
        }
        
        .joystick-base {
            width: 100%;
            height: 100%;
            background: rgba(255, 0, 0, 0.3);
            border-radius: 50%;
            border: 2px solid rgba(255, 255, 255, 0.5);
            position: absolute;
        }
        
        .joystick-stick {
            width: 15vmin;
            height: 15vmin;
            background: rgba(255, 255, 255, 0.9);
            border-radius: 50%;
            position: absolute;
            top: 7.5vmin;
            left: 7.5vmin;
            transition: transform 0.1s;
        }
        
        /* Область для поворота камеры */
        #cameraTouchArea {
            position: absolute;
            top: 0;
            right: 0;
            width: 50%;
            height: 100%;
            pointer-events: auto;
        }

        /* Кнопка стрельбы - УМЕНЬШЕНА */
        #shootButton {
            position: absolute;
            bottom: 15vmin;
            right: 15vmin;
            width: 25vmin;
            height: 25vmin;
            background: rgba(255, 0, 0, 0.3);
            border-radius: 50%;
            border: 2px solid rgba(255, 255, 255, 0.5);
            pointer-events: auto;
            display: flex;
            justify-content: center;
            align-items: center;
            color: white;
            font-size: 5vmin;
            z-index: 60;
        }

        /* Оружие */
        #weapon {
            position: absolute;
            bottom: 0;
            left: 50%;
            transform: translateX(-50%);
            width: 40vmin;
            max-width: 400px;
            height: auto;
            pointer-events: none;
            z-index: 40;
            display: none;
        }

        /* Запрет перетаскивания для всех изображений */
        img {
            -webkit-user-drag: none;
            user-drag: none;
            -webkit-touch-callout: none;
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            user-select: none;
            pointer-events: none;
        }

        /* Разрешаем pointer-events только для кликабельных кнопок */
        .menu-button {
            pointer-events: auto;
        }

        /* FPS счетчик */
        #fpsCounter {
            position: absolute;
            top: 10px;
            left: 10px;
            color: white;
            font-size: 14px;
            background: rgba(0,0,0,0.5);
            padding: 5px;
            border-radius: 3px;
            display: none;
            z-index: 1000;
        }

        /* UI панель с текстом */
        #uiPanel {
            position: absolute;
            bottom: 20px;
            left: 20px;
            color: white;
            font-size: 24px;
            font-family: 'Arial', sans-serif;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
            z-index: 45;
            display: none;
            pointer-events: none;
        }

        #hpDisplay, #ammoDisplay, #roomDisplay {
            margin-bottom: 10px;
            font-weight: bold;
        }

        #hpDisplay {
            color: #ff4444;
        }

        #ammoDisplay {
            color: #44ff44;
        }

        #roomDisplay {
            color: #4444ff;
        }

        /* Спрайты других игроков */
        .player-sprite {
            position: absolute;
            width: 50px;
            height: 100px;
            background-size: contain;
            background-repeat: no-repeat;
            background-position: center;
            z-index: 30;
            pointer-events: none;
            transform-origin: center bottom;
        }

        /* Статус подключения */
        #connectionStatus {
            position: absolute;
            top: 10px;
            right: 10px;
            color: white;
            font-size: 14px;
            background: rgba(0,0,0,0.5);
            padding: 5px;
            border-radius: 3px;
            z-index: 1000;
            display: none;
        }
    </style>
</head>
<body>
    
    <!-- Стартовое меню -->
    <div id="startMenu">
        <img src="MenuUi/Logo.png" alt="DOOM" class="logo">
        <div class="menu-buttons">
            <img src="MenuUi/PlayText.png" alt="Играть" class="menu-button" id="playButton">
            <img src="MenuUi/ConnectText.png" alt="Подключиться" class="menu-button" id="connectButton">
            <img src="MenuUi/OptionsText.png" alt="Настройки" class="menu-button" id="optionsButton">
        </div>
        <img src="MenuUi/companyname.png" alt="Company Name" class="company-name">
    </div>
    
    <!-- Меню подключения -->
    <div id="connectMenu">
        <img src="MenuUi/ConnectText.png" alt="ПОДКЛЮЧЕНИЕ" class="connect-title">
        
        <input type="text" id="roomCodeInput" class="connect-input" placeholder="Введите код комнаты (6 цифр)" maxlength="6" pattern="[0-9]{6}">
        
        <div class="connect-buttons">
            <img src="MenuUi/JoinText.png" alt="ПРИСОЕДИНИТЬСЯ" class="menu-button" id="joinButton">
            <img src="MenuUi/BackText.png" alt="НАЗАД" class="menu-button" id="connectBackButton">
        </div>
    </div>
    
    <!-- Меню настроек -->
    <div id="optionsMenu">
        <img src="MenuUi/OptionsText.png" alt="НАСТРОЙКИ" class="options-title">
        
        <div class="option-item">
            <label>
                Громкость музыки: 
                <input type="range" id="musicVolumeSlider" min="0" max="100" value="50">
            </label>
        </div>
        
        <div class="option-item">
            <label>
                Громкость звуков: 
                <input type="range" id="soundVolumeSlider" min="0" max="100" value="50">
            </label>
        </div>
        
        <div class="option-item">
            <label>
                Чувствительность: 
                <input type="range" id="sensitivitySlider" min="1" max="10" value="5">
            </label>
        </div>
        
        <img src="MenuUi/BackText.png" alt="НАЗАД" class="back-button" id="backButton">
    </div>
    
    <!-- Мобильное управление -->
    <div id="mobileControls">
        <div id="movementJoystick">
            <div class="joystick-base"></div>
            <div class="joystick-stick" id="joystickStick"></div>
        </div>
        
        <!-- Область для поворота камеры -->
        <div id="cameraTouchArea"></div>
        
        <!-- Кнопка стрельбы -->
        <div id="shootButton">FIRE</div>
    </div>
    
    <!-- Оружие -->
    <img id="weapon" src="Guns/DefaultShootGun/Gun.png" alt="Weapon">
    
    <!-- UI Панель с текстом -->
    <div id="uiPanel">
        <div id="roomDisplay">КОМНАТА: ----</div>
        <div id="hpDisplay">HP: 100</div>
        <div id="ammoDisplay">ПАТРОНЫ: 2/2</div>
    </div>
    
    <!-- FPS счетчик -->
    <div id="fpsCounter">FPS: 0</div>
    
    <!-- Статус подключения -->
    <div id="connectionStatus">Подключение...</div>
    
    <!-- Контейнер для спрайтов других игроков -->
    <div id="otherPlayers"></div>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/photon-pun@2.19/pun.min.js"></script>
    <script>
        // ЖЕСТКИЙ ЗАПРЕТ КОНТЕКСТНОГО МЕНЮ И ПЕРЕТАСКИВАНИЯ
        document.addEventListener('contextmenu', function(e) {
            e.preventDefault();
            return false;
        });
        
        document.addEventListener('dragstart', function(e) {
            e.preventDefault();
            return false;
        });

        document.addEventListener('selectstart', function(e) {
            e.preventDefault();
            return false;
        });

        // Photon PUN настройки
        const photonAppId = 'b5d37841-1bb5-401f-a1b9-3349609baa63'; // Замените на ваш App ID
        let gameClient = null;
        let currentRoom = null;
        let localPlayer = null;
        let otherPlayers = new Map();
        let isConnected = false;

        // Спрайты игроков
        const playerSprites = {
            front: ['GameUi/Player/Front/0.png'],
            back: ['GameUi/Player/Back/0.png'],
            left: ['GameUi/Player/Left/0.png'],
            right: ['GameUi/Player/Right/0.png']
        };

        // Предзагрузка спрайтов
        function preloadPlayerSprites() {
            // Загружаем базовые спрайты
            for (let direction in playerSprites) {
                playerSprites[direction].forEach((sprite, index) => {
                    const img = new Image();
                    img.src = sprite;
                });
            }
            
            // Загружаем анимации ходьбы
            for (let i = 1; i <= 4; i++) {
                const frontImg = new Image();
                frontImg.src = `GameUi/Player/Front/${i}.png`;
                playerSprites.front.push(`GameUi/Player/Front/${i}.png`);
                
                const backImg = new Image();
                backImg.src = `GameUi/Player/Back/${i}.png`;
                playerSprites.back.push(`GameUi/Player/Back/${i}.png`);
            }
            
            for (let i = 1; i <= 3; i++) {
                const leftImg = new Image();
                leftImg.src = `GameUi/Player/Left/${i}.png`;
                playerSprites.left.push(`GameUi/Player/Left/${i}.png`);
                
                const rightImg = new Image();
                rightImg.src = `GameUi/Player/Right/${i}.png`;
                playerSprites.right.push(`GameUi/Player/Right/${i}.png`);
            }
        }

        // Инициализация Photon PUN
        function initPhoton() {
            gameClient = new Photon.LoadBalancing.LoadBalancingClient(photonAppId, "1.0");
            
            gameClient.onStateChange = (state) => {
                console.log('Photon state changed:', state);
                updateConnectionStatus(state);
            };
            
            gameClient.onJoinRoom = () => {
                console.log('Joined room successfully');
                currentRoom = gameClient.room;
                isConnected = true;
                
                // Создаем локального игрока
                createLocalPlayer();
                
                // Запускаем игру
                startGame();
            };
            
            gameClient.onLeaveRoom = () => {
                console.log('Left room');
                currentRoom = null;
                isConnected = false;
                cleanupPlayers();
            };
            
            gameClient.onPlayerJoin = (player) => {
                console.log('Player joined:', player.id);
                if (player !== gameClient.localPlayer) {
                    createOtherPlayer(player);
                }
            };
            
            gameClient.onPlayerLeave = (player) => {
                console.log('Player left:', player.id);
                removeOtherPlayer(player);
            };
            
            gameClient.onCustomEvent = (code, content, sender) => {
                if (code === 'PLAYER_UPDATE' && sender !== gameClient.localPlayer) {
                    updateOtherPlayer(sender, content);
                }
            };
        }

        // Обновление статуса подключения
        function updateConnectionStatus(state) {
            const statusElement = document.getElementById('connectionStatus');
            const statusText = {
                [Photon.LoadBalancing.LoadBalancingClient.State.Joined]: 'Подключено',
                [Photon.LoadBalancing.LoadBalancingClient.State.Joining]: 'Подключение...',
                [Photon.LoadBalancing.LoadBalancingClient.State.Disconnected]: 'Отключено',
                [Photon.LoadBalancing.LoadBalancingClient.State.Error]: 'Ошибка'
            };
            
            statusElement.textContent = statusText[state] || state;
            statusElement.style.display = 'block';
        }

        // Создание локального игрока
        function createLocalPlayer() {
            localPlayer = {
                id: gameClient.localPlayer.id,
                position: { x: camera.position.x, y: camera.position.z },
                rotation: yaw,
                animation: 'idle',
                direction: 'front'
            };
        }

        // Создание спрайта другого игрока
        function createOtherPlayer(player) {
            const playerElement = document.createElement('div');
            playerElement.className = 'player-sprite';
            playerElement.id = `player-${player.id}`;
            playerElement.style.backgroundImage = `url('${playerSprites.front[0]}')`;
            document.getElementById('otherPlayers').appendChild(playerElement);
            
            otherPlayers.set(player.id, {
                element: playerElement,
                data: {
                    position: { x: 0, y: 0 },
                    rotation: 0,
                    animation: 'idle',
                    direction: 'front'
                }
            });
        }

        // Удаление спрайта другого игрока
        function removeOtherPlayer(player) {
            const playerElement = document.getElementById(`player-${player.id}`);
            if (playerElement) {
                playerElement.remove();
            }
            otherPlayers.delete(player.id);
        }

        // Обновление данных другого игрока
        function updateOtherPlayer(player, data) {
            const otherPlayer = otherPlayers.get(player.id);
            if (otherPlayer) {
                otherPlayer.data = data;
                updatePlayerSprite(otherPlayer.element, data);
            }
        }

        // Очистка всех игроков
        function cleanupPlayers() {
            otherPlayers.forEach((player, id) => {
                player.element.remove();
            });
            otherPlayers.clear();
            localPlayer = null;
        }

        // Обновление спрайта игрока
        function updatePlayerSprite(element, playerData) {
            // Определяем направление на основе вращения
            let direction = 'front';
            const angle = playerData.rotation;
            
            if (angle >= -Math.PI/4 && angle < Math.PI/4) {
                direction = 'front';
            } else if (angle >= Math.PI/4 && angle < 3*Math.PI/4) {
                direction = 'left';
            } else if (angle >= -3*Math.PI/4 && angle < -Math.PI/4) {
                direction = 'right';
            } else {
                direction = 'back';
            }
            
            // Определяем анимацию
            const animationIndex = playerData.animation === 'walking' ? 
                (Math.floor(Date.now() / 200) % 6) + 1 : 0;
            
            // Получаем правильный спрайт
            let spritePath;
            if (direction === 'front' || direction === 'back') {
                const frames = playerSprites[direction];
                spritePath = frames[Math.min(animationIndex, frames.length - 1)];
            } else {
                const frames = playerSprites[direction];
                const walkCycle = [1, 2, 3, 2, 1];
                const frameIndex = playerData.animation === 'walking' ? 
                    walkCycle[Math.floor(Date.now() / 200) % 5] : 0;
                spritePath = frames[Math.min(frameIndex, frames.length - 1)];
            }
            
            element.style.backgroundImage = `url('${spritePath}')`;
            
            // Позиционируем спрайт в мировых координатах
            const screenPos = worldToScreenPosition(
                playerData.position.x, 
                1.7, 
                playerData.position.y
            );
            
            if (screenPos) {
                element.style.left = `${screenPos.x - 25}px`;
                element.style.top = `${screenPos.y - 100}px`;
                element.style.transform = `scale(${screenPos.scale})`;
                element.style.display = 'block';
            } else {
                element.style.display = 'none';
            }
        }

        // Преобразование мировых координат в экранные
        function worldToScreenPosition(x, y, z) {
            const vector = new THREE.Vector3(x, y, z);
            vector.project(camera);
            
            const widthHalf = window.innerWidth / 2;
            const heightHalf = window.innerHeight / 2;
            
            vector.x = (vector.x * widthHalf) + widthHalf;
            vector.y = -(vector.y * heightHalf) + heightHalf;
            
            // Проверяем, находится ли точка перед камерой
            if (vector.z < 1) {
                // Вычисляем масштаб на основе расстояния
                const distance = camera.position.distanceTo(new THREE.Vector3(x, y, z));
                const scale = Math.max(0.3, 1 - (distance / 20));
                
                return {
                    x: vector.x,
                    y: vector.y,
                    scale: scale
                };
            }
            
            return null;
        }

        // Отправка данных игрока
        function sendPlayerUpdate() {
            if (!isConnected || !localPlayer) return;
            
            // Обновляем данные локального игрока
            localPlayer.position.x = camera.position.x;
            localPlayer.position.y = camera.position.z;
            localPlayer.rotation = yaw;
            
            // Определяем анимацию и направление
            localPlayer.animation = (moveForward || moveBackward || moveLeft || moveRight) ? 'walking' : 'idle';
            
            // Отправляем данные другим игрокам
            gameClient.sendEvent('PLAYER_UPDATE', localPlayer);
        }

        // Подключение к комнате
        function connectToRoom(roomCode) {
            if (!gameClient) {
                console.error('Photon client not initialized');
                return;
            }
            
            const roomOptions = {
                roomName: roomCode,
                maxPlayers: 8,
                playerTtl: 0,
                emptyRoomTtl: 0
            };
            
            gameClient.joinRoom(roomOptions);
        }

        // Создание случайной комнаты
        function createRandomRoom() {
            const roomCode = Math.floor(100000 + Math.random() * 900000).toString();
            document.getElementById('roomDisplay').textContent = `КОМНАТА: ${roomCode}`;
            connectToRoom(roomCode);
        }

        // Базовые настройки Three.js
        const scene = new THREE.Scene();
        
        // ТУМАН - добавляем в сцену (теперь нельзя отключить)
        scene.fog = new THREE.Fog(0x87CEEB, 20, 50);
        
        // Камера с МЕНЬШЕЙ дальностью прорисовки
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 50);
        
        const renderer = new THREE.WebGLRenderer({ 
            antialias: true,
            powerPreference: "high-performance"
        });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setClearColor(0x87CEEB);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        document.body.appendChild(renderer.domElement);

        // Параметры лабиринта
        const CELL_SIZE = 8;
        const WALL_HEIGHT = 8;
        const WALL_THICKNESS = 0.3;

        // Текстуры
        const textureLoader = new THREE.TextureLoader();
        let wallTexture, floorTexture, roofTexture;

        // Загрузка текстур
        function loadTextures() {
            return new Promise((resolve) => {
                let texturesLoaded = 0;
                const totalTextures = 3;

                function onTextureLoad() {
                    texturesLoaded++;
                    if (texturesLoaded === totalTextures) {
                        resolve();
                    }
                }

                wallTexture = textureLoader.load('Textures/WallTex.jpg', onTextureLoad, undefined, (error) => {
                    console.error('Ошибка загрузки текстуры стен:', error);
                    wallTexture = null;
                    onTextureLoad();
                });

                floorTexture = textureLoader.load('Textures/FloorTex.jpg', onTextureLoad, undefined, (error) => {
                    console.error('Ошибка загрузки текстуры пола:', error);
                    floorTexture = null;
                    onTextureLoad();
                });

                roofTexture = textureLoader.load('Textures/RoofTex.jpg', onTextureLoad, undefined, (error) => {
                    console.error('Ошибка загрузки текстуры потолка:', error);
                    roofTexture = null;
                    onTextureLoad();
                });

                // НАСТРОЙКИ ТЕКСТУР
                if (wallTexture) {
                    wallTexture.wrapS = wallTexture.wrapT = THREE.RepeatWrapping;
                    wallTexture.repeat.set(1, 1);
                    wallTexture.minFilter = THREE.LinearFilter;
                    wallTexture.magFilter = THREE.LinearFilter;
                }
                if (floorTexture) {
                    floorTexture.wrapS = floorTexture.wrapT = THREE.RepeatWrapping;
                    floorTexture.repeat.set(20, 20);
                    floorTexture.minFilter = THREE.LinearFilter;
                    floorTexture.magFilter = THREE.LinearFilter;
                }
                if (roofTexture) {
                    roofTexture.wrapS = roofTexture.wrapT = THREE.RepeatWrapping;
                    roofTexture.repeat.set(20, 20);
                    roofTexture.minFilter = THREE.LinearFilter;
                    roofTexture.magFilter = THREE.LinearFilter;
                }
            });
        }

        // Создаем материалы с текстурами
        function createMaterials() {
            const wallMaterial = wallTexture ? 
                new THREE.MeshLambertMaterial({ 
                    map: wallTexture,
                    fog: true
                }) :
                new THREE.MeshLambertMaterial({ 
                    color: 0x8B4513,
                    fog: true
                });
            
            const floorMaterial = floorTexture ? 
                new THREE.MeshLambertMaterial({ 
                    map: floorTexture,
                    fog: true
                }) :
                new THREE.MeshLambertMaterial({ 
                    color: 0x90EE90,
                    fog: true
                });
            
            const roofMaterial = roofTexture ? 
                new THREE.MeshLambertMaterial({ 
                    map: roofTexture,
                    fog: true
                }) :
                new THREE.MeshLambertMaterial({ 
                    color: 0xCCCCCC,
                    fog: true
                });
            
            return { wallMaterial, floorMaterial, roofMaterial };
        }

        // Генератор лабиринта
        class MazeGenerator {
            constructor(width, height) {
                this.width = width;
                this.height = height;
                this.maze = this.generateMazeWithMultiplePaths();
            }

            generateMazeWithMultiplePaths() {
                let maze = Array(this.height).fill().map(() => Array(this.width).fill(1));
                const paths = [];
                const numPaths = 3;
                
                for (let i = 0; i < numPaths; i++) {
                    let startX = 1 + Math.floor(Math.random() * (this.width - 3));
                    let startY = 1 + Math.floor(Math.random() * (this.height - 3));
                    paths.push(this.generatePath(maze, startX, startY));
                }
                
                this.connectPaths(maze, paths);
                this.addRandomPassages(maze);
                
                return maze;
            }

            generatePath(maze, startX, startY) {
                let x = startX, y = startY;
                maze[y][x] = 0;
                
                let path = [[x, y]];
                let directions = [[0, 2], [2, 0], [0, -2], [-2, 0]];
                let stack = [[x, y]];
                
                while (stack.length > 0) {
                    let [cx, cy] = stack[stack.length - 1];
                    
                    let possibleDirs = directions.filter(([dx, dy]) => {
                        let nx = cx + dx, ny = cy + dy;
                        return nx > 0 && nx < this.width - 1 && 
                               ny > 0 && ny < this.height - 1 && 
                               maze[ny][nx] === 1;
                    });
                    
                    if (possibleDirs.length > 0) {
                        let [dx, dy] = possibleDirs[Math.floor(Math.random() * possibleDirs.length)];
                        let nx = cx + dx, ny = cy + dy;
                        
                        maze[cy + dy/2][cx + dx/2] = 0;
                        maze[ny][nx] = 0;
                        
                        path.push([nx, ny]);
                        stack.push([nx, ny]);
                    } else {
                        stack.pop();
                    }
                }
                
                return path;
            }

            connectPaths(maze, paths) {
                for (let i = 0; i < paths.length - 1; i++) {
                    const connectionPoints = 2;
                    for (let j = 0; j < connectionPoints; j++) {
                        const point1 = paths[i][Math.floor(Math.random() * paths[i].length)];
                        const point2 = paths[i+1][Math.floor(Math.random() * paths[i+1].length)];
                        this.createPassage(maze, point1, point2);
                    }
                }
            }

            createPassage(maze, [x1, y1], [x2, y2]) {
                let x = x1, y = y1;
                while (x !== x2 || y !== y2) {
                    if (Math.random() > 0.5 && x !== x2) {
                        x += x < x2 ? 1 : -1;
                    } else if (y !== y2) {
                        y += y < y2 ? 1 : -1;
                    }
                    if (x > 0 && x < this.width - 1 && y > 0 && y < this.height - 1) {
                        maze[y][x] = 0;
                    }
                }
            }

            addRandomPassages(maze) {
                const numExtraPassages = Math.floor(this.width * this.height * 0.1);
                for (let i = 0; i < numExtraPassages; i++) {
                    const x = 1 + Math.floor(Math.random() * (this.width - 2));
                    const y = 1 + Math.floor(Math.random() * (this.height - 2));
                    if (maze[y][x] === 1) {
                        const neighbors = [
                            [x-1, y], [x+1, y], [x, y-1], [x, y+1]
                        ].filter(([nx, ny]) => 
                            nx >= 0 && nx < this.width && ny >= 0 && ny < this.height
                        );
                        const passageNeighbors = neighbors.filter(([nx, ny]) => maze[ny][nx] === 0);
                        if (passageNeighbors.length >= 2) {
                            maze[y][x] = 0;
                        }
                    }
                }
            }

            getMaze() {
                return this.maze;
            }
        }

        // Создаем лабиринт
        const mazeGen = new MazeGenerator(25, 25);
        const maze = mazeGen.getMaze();

        // Освещение
        const ambientLight = new THREE.AmbientLight(0xffffff, 1.0);
        scene.add(ambientLight);
        
        const directionalLight1 = new THREE.DirectionalLight(0xffffff, 0.8);
        directionalLight1.position.set(50, 100, 50);
        scene.add(directionalLight1);
        
        const directionalLight2 = new THREE.DirectionalLight(0xffffff, 0.6);
        directionalLight2.position.set(-50, 80, -50);
        scene.add(directionalLight2);

        // Создание сцены
        function createScene(materials) {
            createFloor(materials.floorMaterial);
            createRoof(materials.roofMaterial);
            createMazeWalls(materials.wallMaterial);
        }

        function createFloor(floorMaterial) {
            const floorWidth = maze[0].length * CELL_SIZE;
            const floorHeight = maze.length * CELL_SIZE;
            const floorGeometry = new THREE.PlaneGeometry(floorWidth, floorHeight);
            const floor = new THREE.Mesh(floorGeometry, floorMaterial);
            floor.rotation.x = -Math.PI / 2;
            floor.position.y = -1;
            scene.add(floor);
        }

        function createRoof(roofMaterial) {
            const roofWidth = maze[0].length * CELL_SIZE;
            const roofHeight = maze.length * CELL_SIZE;
            const roofGeometry = new THREE.PlaneGeometry(roofWidth, roofHeight);
            const roof = new THREE.Mesh(roofGeometry, roofMaterial);
            roof.rotation.x = Math.PI / 2;
            roof.position.y = WALL_HEIGHT - 1;
            scene.add(roof);
        }

        function createMazeWalls(wallMaterial) {
            const wallGroup = new THREE.Group();
            
            for (let y = 0; y < maze.length; y++) {
                for (let x = 0; x < maze[y].length - 1; x++) {
                    if (maze[y][x] === 1 || maze[y][x+1] === 1) {
                        if (maze[y][x] !== maze[y][x+1]) {
                            const wallGeometry = new THREE.BoxGeometry(WALL_THICKNESS, WALL_HEIGHT, CELL_SIZE);
                            const wall = new THREE.Mesh(wallGeometry, wallMaterial);
                            wall.position.set(
                                (x + 0.5 - maze[0].length/2) * CELL_SIZE, 
                                WALL_HEIGHT/2 - 1,
                                (y - maze.length/2) * CELL_SIZE
                            );
                            wallGroup.add(wall);
                        }
                    }
                }
            }

            for (let y = 0; y < maze.length - 1; y++) {
                for (let x = 0; x < maze[y].length; x++) {
                    if (maze[y][x] === 1 || maze[y+1][x] === 1) {
                        if (maze[y][x] !== maze[y+1][x]) {
                            const wallGeometry = new THREE.BoxGeometry(CELL_SIZE, WALL_HEIGHT, WALL_THICKNESS);
                            const wall = new THREE.Mesh(wallGeometry, wallMaterial);
                            wall.position.set(
                                (x - maze[0].length/2) * CELL_SIZE, 
                                WALL_HEIGHT/2 - 1,
                                (y + 0.5 - maze.length/2) * CELL_SIZE
                            );
                            wallGroup.add(wall);
                        }
                    }
                }
            }

            scene.add(wallGroup);
        }

        // Позиция игрока
        function findRandomStartPosition() {
            let freeCells = [];
            for (let y = 1; y < maze.length - 1; y++) {
                for (let x = 1; x < maze[y].length - 1; x++) {
                    if (maze[y][x] === 0) {
                        freeCells.push({x, y});
                    }
                }
            }
            
            if (freeCells.length > 0) {
                const randomCell = freeCells[Math.floor(Math.random() * freeCells.length)];
                return {
                    x: (randomCell.x - maze[0].length/2) * CELL_SIZE,
                    z: (randomCell.y - maze.length/2) * CELL_SIZE
                };
            }
            
            return {
                x: (-maze[0].length/2 + 1) * CELL_SIZE,
                z: (-maze.length/2 + 1) * CELL_SIZE
            };
        }

        const startPos = findRandomStartPosition();
        camera.position.set(startPos.x, 1.7, startPos.z);
        
        // Переменные управления
        let moveForward = false;
        let moveBackward = false;
        let moveLeft = false;
        let moveRight = false;
        
        let yaw = 0;
        let pitch = 0;
        const PI_2 = Math.PI / 2;

        // Настройки
        let mouseSensitivity = 0.002;

        // Аудио система
        let musicVolume = 0.5;
        let soundVolume = 0.5;
        let currentMusic = null;
        let musicTracks = [];
        let currentTrackIndex = 0;
        let musicStarted = false;

        // Звуковые эффекты
        let shootSound = null;
        let reloadSound = null;

        // Оружие
        const weapon = document.getElementById('weapon');
        let isShooting = false;
        let isReloading = false;
        let canShoot = true;
        let ammo = 2;
        let maxAmmo = 2;
        let hp = 100;
        
        // Переменные для автоматической стрельбы
        let isMouseDown = false;
        let autoShootInterval = null;
        let lastShootTime = 0;
        const SHOOT_DELAY = 300; // Задержка между выстрелами в мс

        // Предзагрузка изображений оружия
        const gunImages = {
            normal: 'Guns/DefaultShootGun/Gun.png',
            shoot1: 'Guns/DefaultShootGun/GunSh1.png',
            shoot2: 'Guns/DefaultShootGun/GunSh2.png',
            reload1: 'Guns/DefaultShootGun/GunKD1.png',
            reload2: 'Guns/DefaultShootGun/GunKD2.png',
            reload3: 'Guns/DefaultShootGun/GunKD3.png'
        };

        // Функция предзагрузки изображений
        function preloadWeaponImages() {
            Object.values(gunImages).forEach(src => {
                const img = new Image();
                img.src = src;
            });
        }

        // Инициализация аудио системы
        function initAudio() {
            // Создаем звуковые эффекты
            shootSound = new Audio('Sounds/Shoot.mp3');
            reloadSound = new Audio('Sounds/Reload.mp3');
            
            // Настраиваем звуковые эффекты
            shootSound.volume = soundVolume;
            reloadSound.volume = soundVolume;
            
            // Предзагружаем звуки
            shootSound.preload = 'auto';
            reloadSound.preload = 'auto';
            
            // Создаем список музыкальных треков (только 3 трека)
            musicTracks = [
                'Sounds/MenuMusic.mp3',
                'Sounds/MenuMusic1.mp3',
                'Sounds/MenuMusic2.mp3'
            ];
            
            console.log('Загружено музыкальных треков:', musicTracks.length);
            
            // Случайный выбор первого трека
            currentTrackIndex = Math.floor(Math.random() * musicTracks.length);
        }

        // Функция для воспроизведения следующего трека
        function playNextTrack() {
            if (musicTracks.length === 0) {
                console.log('Нет музыкальных треков для воспроизведения');
                return;
            }
            
            // Останавливаем текущую музыку
            if (currentMusic) {
                currentMusic.pause();
                currentMusic.currentTime = 0;
                currentMusic.removeEventListener('ended', playNextTrack);
            }
            
            // Переходим к следующему треку
            currentTrackIndex = (currentTrackIndex + 1) % musicTracks.length;
            
            console.log('Воспроизведение трека:', musicTracks[currentTrackIndex]);
            
            // Создаем новый аудио элемент
            currentMusic = new Audio(musicTracks[currentTrackIndex]);
            currentMusic.volume = musicVolume;
            currentMusic.loop = false; // Не зацикливаем, чтобы переходить к следующему
            
            // Когда трек заканчивается, играем следующий
            currentMusic.addEventListener('ended', playNextTrack);
            
            // Пытаемся воспроизвести
            const playPromise = currentMusic.play();
            
            if (playPromise !== undefined) {
                playPromise.then(() => {
                    console.log('Музыка успешно запущена');
                    musicStarted = true;
                }).catch(error => {
                    console.log('Автовоспроизведение музыки заблокировано:', error);
                    // Пытаемся снова при взаимодействии
                    document.addEventListener('click', startMusicOnInteraction, { once: true });
                    document.addEventListener('touchstart', startMusicOnInteraction, { once: true });
                });
            }
        }

        // Функция запуска музыки
        function startMusic() {
            if (musicStarted) return;
            
            console.log('Запуск музыки...');
            playNextTrack();
        }

        // Функция для принудительного запуска музыки при взаимодействии
        function startMusicOnInteraction() {
            if (!musicStarted) {
                console.log('Принудительный запуск музыки после взаимодействия');
                startMusic();
            }
        }

        // Обновление громкости
        function updateVolumes() {
            if (currentMusic) {
                currentMusic.volume = musicVolume;
            }
            if (shootSound) {
                shootSound.volume = soundVolume;
            }
            if (reloadSound) {
                reloadSound.volume = soundVolume;
            }
        }

        // Обновление UI
        function updateUI() {
            document.getElementById('hpDisplay').textContent = `HP: ${hp}`;
            document.getElementById('ammoDisplay').textContent = `ПАТРОНЫ: ${ammo}/${maxAmmo}`;
        }

        // Анимация выстрела - ИСПРАВЛЕННАЯ ВЕРСИЯ
        function playShootAnimation() {
            // Проверяем возможность стрельбы
            if (!canShoot || isReloading || isShooting || ammo <= 0) {
                return;
            }
            
            isShooting = true;
            canShoot = false;
            ammo--;
            updateUI();
            
            // Сразу меняем на первый кадр выстрела
            weapon.src = gunImages.shoot1;
            
            // Звук выстрела
            if (shootSound) {
                shootSound.currentTime = 0;
                shootSound.play().catch(e => console.log('Не удалось воспроизвести звук выстрела'));
            }
            
            // Второй кадр выстрела
            setTimeout(() => {
                if (!isShooting) return;
                weapon.src = gunImages.shoot2;
            }, 50);
            
            // Возврат к нормальному состоянию
            setTimeout(() => {
                if (!isShooting) return;
                weapon.src = gunImages.normal;
                isShooting = false;
                
                // Если патроны кончились - перезарядка
                if (ammo <= 0) {
                    playReloadAnimation();
                } else {
                    // Задержка между выстрелами
                    setTimeout(() => {
                        canShoot = true;
                    }, 300);
                }
            }, 150);
        }

        // Анимация перезарядки - ИСПРАВЛЕННАЯ ВЕРСИЯ
        function playReloadAnimation() {
            if (isReloading || ammo >= maxAmmo) {
                return;
            }
            
            isReloading = true;
            canShoot = false;
            
            // Звук перезарядки
            if (reloadSound) {
                reloadSound.currentTime = 0;
                reloadSound.play().catch(e => console.log('Не удалось воспроизвести звук перезарядки'));
            }
            
            // Первый кадр перезарядки
            setTimeout(() => {
                if (!isReloading) return;
                weapon.src = gunImages.reload1;
            }, 100);
            
            // Второй кадр перезарядки
            setTimeout(() => {
                if (!isReloading) return;
                weapon.src = gunImages.reload2;
            }, 300);
            
            // Третий кадр перезарядки
            setTimeout(() => {
                if (!isReloading) return;
                weapon.src = gunImages.reload3;
            }, 500);
            
            // Завершение перезарядки
            setTimeout(() => {
                if (!isReloading) return;
                weapon.src = gunImages.normal;
                ammo = maxAmmo;
                isReloading = false;
                canShoot = true;
                updateUI();
            }, 700);
        }

        // Функция для автоматической стрельбы при удержании
        function startAutoShoot() {
            if (autoShootInterval) return;
            
            autoShootInterval = setInterval(() => {
                const currentTime = Date.now();
                if (currentTime - lastShootTime >= SHOOT_DELAY) {
                    playShootAnimation();
                    lastShootTime = currentTime;
                }
            }, 100); // Проверяем каждые 100мс
        }

        function stopAutoShoot() {
            if (autoShootInterval) {
                clearInterval(autoShootInterval);
                autoShootInterval = null;
            }
        }

        // FPS счетчик
        const fpsCounter = document.getElementById('fpsCounter');
        let frameCount = 0;
        let lastTime = performance.now();
        let fps = 0;

        // УПРАВЛЕНИЕ
        let activeTouches = new Map();
        let isShootingTouch = false;
        let shootTouchId = null;
        let lastCameraTouchX = 0;
        let lastCameraTouchY = 0;

        // Инициализация джойстика
        function initJoystick() {
            const joystickStick = document.getElementById('joystickStick');
            const joystickBase = document.getElementById('movementJoystick');
            
            let baseRect = joystickBase.getBoundingClientRect();
            const baseCenterX = baseRect.left + baseRect.width / 2;
            const baseCenterY = baseRect.top + baseRect.height / 2;
            const maxDistance = baseRect.width / 3;

            function updateJoystick(touch) {
                const touchX = touch.clientX;
                const touchY = touch.clientY;
                
                const deltaX = touchX - baseCenterX;
                const deltaY = touchY - baseCenterY;
                const distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);
                
                let stickX = deltaX;
                let stickY = deltaY;
                
                if (distance > maxDistance) {
                    const angle = Math.atan2(deltaY, deltaX);
                    stickX = Math.cos(angle) * maxDistance;
                    stickY = Math.sin(angle) * maxDistance;
                }
                
                joystickStick.style.transform = `translate(${stickX}px, ${stickY}px)`;
                
                const normalizedX = stickX / maxDistance;
                const normalizedY = stickY / maxDistance;
                
                moveForward = normalizedY < -0.3;
                moveBackward = normalizedY > 0.3;
                moveLeft = normalizedX < -0.3;
                moveRight = normalizedX > 0.3;
            }

            function resetJoystick() {
                joystickStick.style.transform = 'translate(0, 0)';
                moveForward = moveBackward = moveLeft = moveRight = false;
            }

            // Обработка событий джойстика
            joystickBase.addEventListener('touchstart', (e) => {
                e.preventDefault();
                const touch = e.changedTouches[0];
                const rect = joystickBase.getBoundingClientRect();
                const touchX = touch.clientX;
                const touchY = touch.clientY;
                
                if (touchX >= rect.left && touchX <= rect.right && 
                    touchY >= rect.top && touchY <= rect.bottom) {
                    activeTouches.set(touch.identifier, { 
                        type: 'joystick', 
                        element: joystickBase
                    });
                    updateJoystick(touch);
                }
            });
        }

        // Инициализация поворота камеры и стрельбы
        function initCameraControls() {
            const cameraArea = document.getElementById('cameraTouchArea');
            const shootButton = document.getElementById('shootButton');

            cameraArea.addEventListener('touchstart', (e) => {
                e.preventDefault();
                const touch = e.changedTouches[0];
                
                const shootRect = shootButton.getBoundingClientRect();
                const touchX = touch.clientX;
                const touchY = touch.clientY;
                
                if (!(touchX >= shootRect.left && touchX <= shootRect.right && 
                      touchY >= shootRect.top && touchY <= shootRect.bottom)) {
                    activeTouches.set(touch.identifier, { 
                        type: 'camera', 
                        element: cameraArea,
                        lastX: touch.clientX,
                        lastY: touch.clientY
                    });
                    lastCameraTouchX = touch.clientX;
                    lastCameraTouchY = touch.clientY;
                }
            });

            // Кнопка стрельбы
            shootButton.addEventListener('touchstart', (e) => {
                e.preventDefault();
                const touch = e.changedTouches[0];
                
                shootTouchId = touch.identifier;
                isShootingTouch = true;
                lastCameraTouchX = touch.clientX;
                lastCameraTouchY = touch.clientY;
                
                playShootAnimation();
            });

            shootButton.addEventListener('touchend', (e) => {
                e.preventDefault();
                for (let touch of e.changedTouches) {
                    if (touch.identifier === shootTouchId) {
                        isShootingTouch = false;
                        shootTouchId = null;
                        break;
                    }
                }
            });
        }

        // ОБЩИЕ ОБРАБОТЧИКИ
        function initGlobalHandlers() {
            document.addEventListener('touchmove', (e) => {
                e.preventDefault();
                
                for (let touch of e.touches) {
                    const touchData = activeTouches.get(touch.identifier);
                    
                    if (touchData && touchData.type === 'joystick') {
                        const joystickStick = document.getElementById('joystickStick');
                        const joystickBase = document.getElementById('movementJoystick');
                        
                        let baseRect = joystickBase.getBoundingClientRect();
                        const baseCenterX = baseRect.left + baseRect.width / 2;
                        const baseCenterY = baseRect.top + baseRect.height / 2;
                        const maxDistance = baseRect.width / 3;
                        
                        const deltaX = touch.clientX - baseCenterX;
                        const deltaY = touch.clientY - baseCenterY;
                        const distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);
                        
                        let stickX = deltaX;
                        let stickY = deltaY;
                        
                        if (distance > maxDistance) {
                            const angle = Math.atan2(deltaY, deltaX);
                            stickX = Math.cos(angle) * maxDistance;
                            stickY = Math.sin(angle) * maxDistance;
                        }
                        
                        joystickStick.style.transform = `translate(${stickX}px, ${stickY}px)`;
                        
                        const normalizedX = stickX / maxDistance;
                        const normalizedY = stickY / maxDistance;
                        
                        moveForward = normalizedY < -0.3;
                        moveBackward = normalizedY > 0.3;
                        moveLeft = normalizedX < -0.3;
                        moveRight = normalizedX > 0.3;
                        
                    } else if (touchData && touchData.type === 'camera') {
                        if (touchData.lastX && touchData.lastY) {
                            const deltaX = touch.clientX - touchData.lastX;
                            const deltaY = touch.clientY - touchData.lastY;
                            
                            yaw -= deltaX * mouseSensitivity * 2;
                            pitch -= deltaY * mouseSensitivity * 2;
                            pitch = Math.max(-PI_2, Math.min(PI_2, pitch));
                        }
                        
                        touchData.lastX = touch.clientX;
                        touchData.lastY = touch.clientY;
                    }
                    
                    if (touch.identifier === shootTouchId && isShootingTouch) {
                        const deltaX = touch.clientX - lastCameraTouchX;
                        const deltaY = touch.clientY - lastCameraTouchY;
                        
                        yaw -= deltaX * mouseSensitivity * 1.5;
                        pitch -= deltaY * mouseSensitivity * 1.5;
                        pitch = Math.max(-PI_2, Math.min(PI_2, pitch));
                        
                        lastCameraTouchX = touch.clientX;
                        lastCameraTouchY = touch.clientY;
                    }
                }
            });

            document.addEventListener('touchend', (e) => {
                for (let touch of e.changedTouches) {
                    const touchData = activeTouches.get(touch.identifier);
                    if (touchData) {
                        if (touchData.type === 'joystick') {
                            const joystickStick = document.getElementById('joystickStick');
                            joystickStick.style.transform = 'translate(0, 0)';
                            moveForward = moveBackward = moveLeft = moveRight = false;
                        }
                        activeTouches.delete(touch.identifier);
                    }
                    
                    if (touch.identifier === shootTouchId) {
                        isShootingTouch = false;
                        shootTouchId = null;
                    }
                }
            });

            window.addEventListener('blur', () => {
                activeTouches.clear();
                const joystickStick = document.getElementById('joystickStick');
                joystickStick.style.transform = 'translate(0, 0)';
                moveForward = moveBackward = moveLeft = moveRight = false;
                isShootingTouch = false;
                shootTouchId = null;
                stopAutoShoot();
                isMouseDown = false;
            });

            // Управление стрельбой для ПК - ЛКМ (только в игре)
            document.addEventListener('mousedown', (e) => {
                // Проверяем, что игра активна (меню скрыто) и НЕ в настройках
                if (e.button === 0 && 
                    document.getElementById('startMenu').style.display === 'none' &&
                    document.getElementById('optionsMenu').style.display === 'none' &&
                    document.getElementById('connectMenu').style.display === 'none') {
                    e.preventDefault();
                    isMouseDown = true;
                    playShootAnimation();
                    startAutoShoot();
                }
            });

            document.addEventListener('mouseup', (e) => {
                if (e.button === 0) {
                    isMouseDown = false;
                    stopAutoShoot();
                }
            });

            // Перезарядка по кнопке R (только в игре)
            document.addEventListener('keydown', (e) => {
                // Проверяем, что игра активна (меню скрыто) и НЕ в настройках
                if (e.code === 'KeyR' && 
                    document.getElementById('startMenu').style.display === 'none' &&
                    document.getElementById('optionsMenu').style.display === 'none' &&
                    document.getElementById('connectMenu').style.display === 'none') {
                    // Если уже перезаряжаемся или патроны полные - игнорируем
                    if (!isReloading && ammo < maxAmmo) {
                        playReloadAnimation();
                    }
                }
            });
        }

        // Инициализация управления
        function initControls() {
            initJoystick();
            initCameraControls();
            initGlobalHandlers();

            // Клавиатура для десктопа (только в игре)
            window.addEventListener('keydown', (event) => {
                // Проверяем, что игра активна (меню скрыто) и НЕ в настройках
                if (document.getElementById('startMenu').style.display === 'none' &&
                    document.getElementById('optionsMenu').style.display === 'none' &&
                    document.getElementById('connectMenu').style.display === 'none') {
                    switch(event.code) {
                        case 'KeyW': moveForward = true; break;
                        case 'KeyS': moveBackward = true; break;
                        case 'KeyA': moveLeft = true; break;
                        case 'KeyD': moveRight = true; break;
                    }
                }
            });
            
            window.addEventListener('keyup', (event) => {
                // Проверяем, что игра активна (меню скрыто) и НЕ в настройках
                if (document.getElementById('startMenu').style.display === 'none' &&
                    document.getElementById('optionsMenu').style.display === 'none' &&
                    document.getElementById('connectMenu').style.display === 'none') {
                    switch(event.code) {
                        case 'KeyW': moveForward = false; break;
                        case 'KeyS': moveBackward = false; break;
                        case 'KeyA': moveLeft = false; break;
                        case 'KeyD': moveRight = false; break;
                    }
                }
            });

            // Мышь для десктопа (только в игре)
            document.addEventListener('mousemove', (event) => {
                // Проверяем, что игра активна (меню скрыто) и НЕ в настройках
                if (document.getElementById('startMenu').style.display === 'none' &&
                    document.getElementById('optionsMenu').style.display === 'none' && 
                    document.getElementById('connectMenu').style.display === 'none' &&
                    document.pointerLockElement === renderer.domElement) {
                    yaw -= event.movementX * mouseSensitivity;
                    pitch -= event.movementY * mouseSensitivity;
                    pitch = Math.max(-PI_2, Math.min(PI_2, pitch));
                }
            });

            renderer.domElement.addEventListener('click', () => {
                // Запрос блокировки указателя только в игре
                if (document.getElementById('startMenu').style.display === 'none' &&
                    document.getElementById('optionsMenu').style.display === 'none' &&
                    document.getElementById('connectMenu').style.display === 'none') {
                    renderer.domElement.requestPointerLock();
                }
            });
        }

        // Проверка коллизий
        function checkCollision(newX, newZ) {
            const playerRadius = 0.3;
            const points = [
                [newX - playerRadius, newZ],
                [newX + playerRadius, newZ],
                [newX, newZ - playerRadius],
                [newX, newZ + playerRadius]
            ];
            
            for (let [px, pz] of points) {
                const mazeX = Math.round((px / CELL_SIZE) + maze[0].length/2);
                const mazeZ = Math.round((pz / CELL_SIZE) + maze.length/2);
                
                if (mazeZ >= 0 && mazeZ < maze.length && 
                    mazeX >= 0 && mazeX < maze[0].length) {
                    if (maze[mazeZ][mazeX] === 1) {
                        return true;
                    }
                } else {
                    return true;
                }
            }
            
            return false;
        }

        // Анимация с delta time для независимой от FPS скорости
        const BASE_MOVE_SPEED = 15.0;
        
        function animate(currentTime) {
            requestAnimationFrame(animate);
            
            const deltaTime = Math.min((currentTime - lastTime) / 1000, 0.1);
            lastTime = currentTime;
            
            frameCount++;
            if (currentTime > lastTime + 1000) {
                fps = Math.round((frameCount * 1000) / (currentTime - lastTime));
                frameCount = 0;
                lastTime = currentTime;
                fpsCounter.textContent = `FPS: ${fps}`;
            }
            
            camera.rotation.order = 'YXZ';
            camera.rotation.y = yaw;
            camera.rotation.x = pitch;
            
            const direction = new THREE.Vector3();
            
            const actualMoveSpeed = BASE_MOVE_SPEED * deltaTime;
            
            if (moveForward) direction.z -= actualMoveSpeed;
            if (moveBackward) direction.z += actualMoveSpeed;
            if (moveLeft) direction.x -= actualMoveSpeed;
            if (moveRight) direction.x += actualMoveSpeed;
            
            direction.applyEuler(new THREE.Euler(0, yaw, 0));
            
            let newX = camera.position.x;
            let newZ = camera.position.z;
            
            if (!checkCollision(newX + direction.x, newZ)) {
                newX += direction.x;
            }
            if (!checkCollision(newX, newZ + direction.z)) {
                newZ += direction.z;
            }
            
            camera.position.x = newX;
            camera.position.z = newZ;
            
            // Отправляем обновление позиции игрока
            sendPlayerUpdate();
            
            // Обновляем спрайты других игроков
            updateOtherPlayersSprites();
            
            renderer.render(scene, camera);
        }
        
        // Обновление спрайтов других игроков
        function updateOtherPlayersSprites() {
            otherPlayers.forEach((player, id) => {
                updatePlayerSprite(player.element, player.data);
            });
        }
        
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        // Функция запуска игры
        function startGame() {
            document.getElementById('startMenu').style.display = 'none';
            document.getElementById('optionsMenu').style.display = 'none';
            document.getElementById('connectMenu').style.display = 'none';
            fpsCounter.style.display = 'block';
            document.getElementById('uiPanel').style.display = 'block';
            
            if ('ontouchstart' in window || navigator.maxTouchPoints) {
                document.getElementById('mobileControls').style.display = 'block';
            }
            
            weapon.style.display = 'block';
            
            // СБРОС СОСТОЯНИЯ ОРУЖИЯ ПРИ СТАРТЕ ИГРЫ
            ammo = maxAmmo;
            isShooting = false;
            isReloading = false;
            canShoot = true;
            weapon.src = gunImages.normal;
            isMouseDown = false;
            stopAutoShoot();
            
            updateUI();
            
            lastTime = performance.now();
            animate(performance.now());
        }

        // Функции для меню
        function showOptions() {
            document.getElementById('startMenu').style.display = 'none';
            document.getElementById('optionsMenu').style.display = 'flex';
        }

        function hideOptions() {
            document.getElementById('optionsMenu').style.display = 'none';
            document.getElementById('startMenu').style.display = 'flex';
        }

        function showConnect() {
            document.getElementById('startMenu').style.display = 'none';
            document.getElementById('connectMenu').style.display = 'flex';
            document.getElementById('roomCodeInput').focus();
        }

        function hideConnect() {
            document.getElementById('connectMenu').style.display = 'none';
            document.getElementById('startMenu').style.display = 'flex';
        }

        function joinRoom() {
            const roomCode = document.getElementById('roomCodeInput').value;
            if (roomCode.length === 6 && /^\d+$/.test(roomCode)) {
                document.getElementById('roomDisplay').textContent = `КОМНАТА: ${roomCode}`;
                connectToRoom(roomCode);
            } else {
                alert('Пожалуйста, введите 6-значный код комнаты');
            }
        }

        // Инициализация меню
        function initMenu() {
            const playButton = document.getElementById('playButton');
            const connectButton = document.getElementById('connectButton');
            const optionsButton = document.getElementById('optionsButton');
            const backButton = document.getElementById('backButton');
            const joinButton = document.getElementById('joinButton');
            const connectBackButton = document.getElementById('connectBackButton');
            
            // Запускаем музыку при инициализации
            startMusic();
            
            // Добавляем обработчики для принудительного запуска музыки
            document.addEventListener('click', startMusicOnInteraction, { once: true });
            document.addEventListener('touchstart', startMusicOnInteraction, { once: true });
            
            playButton.addEventListener('click', function(e) {
                createRandomRoom();
            });
            
            connectButton.addEventListener('click', function(e) {
                showConnect();
            });
            
            optionsButton.addEventListener('click', function(e) {
                showOptions();
            });
            
            backButton.addEventListener('click', function(e) {
                hideOptions();
            });
            
            joinButton.addEventListener('click', function(e) {
                joinRoom();
            });
            
            connectBackButton.addEventListener('click', function(e) {
                hideConnect();
            });
            
            // Обработка ввода кода комнаты
            document.getElementById('roomCodeInput').addEventListener('keypress', function(e) {
                if (e.key === 'Enter') {
                    joinRoom();
                }
            });
        }

        // Настройки
        document.getElementById('sensitivitySlider').addEventListener('input', function(e) {
            mouseSensitivity = e.target.value * 0.0004;
        });

        document.getElementById('musicVolumeSlider').addEventListener('input', function(e) {
            musicVolume = e.target.value / 100;
            updateVolumes();
        });

        document.getElementById('soundVolumeSlider').addEventListener('input', function(e) {
            soundVolume = e.target.value / 100;
            updateVolumes();
        });

        // Запуск игры
        loadTextures().then(() => {
            const materials = createMaterials();
            createScene(materials);
            initAudio(); // Инициализируем аудио систему
            initPhoton(); // Инициализируем Photon
            initControls();
            initMenu();
            weapon.style.display = 'none';
            
            // Предзагружаем изображения оружия и спрайты игроков
            preloadWeaponImages();
            preloadPlayerSprites();
        }).catch((error) => {
            console.error('Ошибка загрузки:', error);
            const materials = createMaterials();
            createScene(materials);
            initAudio(); // Инициализируем аудио систему даже при ошибках
            initPhoton(); // Инициализируем Photon даже при ошибках
            initControls();
            initMenu();
            weapon.style.display = 'none';
            
            // Предзагружаем изображения оружия и спрайты игроков даже при ошибках
            preloadWeaponImages();
            preloadPlayerSprites();
        });
    </script>
</body>
</html>
