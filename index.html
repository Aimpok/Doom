<!DOCTYPE html>
<html>
<head>
    <title>3D Лабиринт</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <style>
        body { 
            margin: 0; 
            padding: 0; 
            overflow: hidden;
            font-family: Arial, sans-serif;
            touch-action: none;
            -webkit-touch-callout: none;
            -webkit-user-select: none;
            user-select: none;
            background: #000;
        }
        canvas { 
            display: block; 
            touch-action: none;
        }
        
        /* Стартовое меню в стиле DOOM */
        #startMenu {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #000;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 100;
            background-image: url('MenuUi/MenuBg.png');
            background-size: cover;
            background-position: center;
            background-repeat: no-repeat;
        }
        
        .logo {
            width: 55vmin;
            max-width: 800px;
            position: absolute;
            top: 30%;
            transform: translateY(-50%);
            object-fit: contain;
            -webkit-user-drag: none;
            user-drag: none;
            pointer-events: none;
            -webkit-touch-callout: none;
        }
        
        .menu-buttons {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 2.4vmin;
            position: absolute;
            top: 70%;
            transform: translateY(-50%);
        }
        
        .menu-button {
            width: 60vmin;
            max-width: 600px;
            min-width: 250px;
            cursor: pointer;
            transition: all 0.3s ease;
            object-fit: contain;
            -webkit-user-drag: none;
            user-drag: none;
            pointer-events: auto;
            -webkit-touch-callout: none;
            -webkit-tap-highlight-color: transparent;
        }
        
        .menu-button:hover {
            transform: scale(1.05);
        }
        
        .menu-button:active {
            transform: scale(1.02);
        }
        
        .company-name {
            position: absolute;
            bottom: 0vmin;
            width: 28vmin;
            max-width: 300px;
            object-fit: contain;
            -webkit-user-drag: none;
            user-drag: none;
            pointer-events: none;
            opacity: 0.8;
            -webkit-touch-callout: none;
        }

        /* Панель подключения к комнате */
        #connectMenu {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-image: url('MenuUi/MenuBg.png');
            background-size: cover;
            background-position: center;
            background-repeat: no-repeat;
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 110;
            color: white;
        }

        .connect-title {
            width: 60vmin;
            max-width: 600px;
            min-width: 250px;
            margin-bottom: 3vmin;
            object-fit: contain;
        }

        .room-input {
            width: 50vmin;
            max-width: 500px;
            min-width: 200px;
            padding: 2vmin;
            font-size: 3vmin;
            background: rgba(0,0,0,0.8);
            border: 2px solid #444;
            color: white;
            text-align: center;
            margin-bottom: 3vmin;
            border-radius: 10px;
        }

        .connect-buttons {
            display: flex;
            flex-direction: column;
            gap: 2vmin;
            align-items: center;
        }

        /* Экран выбора режима игры */
        #modeSelectMenu {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-image: url('MenuUi/MenuBg.png');
            background-size: cover;
            background-position: center;
            background-repeat: no-repeat;
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 120;
        }

        .mode-select-title {
            width: 60vmin;
            max-width: 600px;
            min-width: 250px;
            margin-bottom: 3vmin;
            object-fit: contain;
            -webkit-user-drag: none;
            user-drag: none;
            pointer-events: none;
        }

        .mode-carousel {
            display: flex;
            align-items: center;
            justify-content: center;
            width: 90%;
            max-width: 1000px;
            height: 50vmin;
            position: relative;
            overflow: hidden;
        }

        .mode-slide {
            position: absolute;
            width: 50vmin;
            height: 40vmin;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            transition: all 0.5s ease;
            opacity: 0.5;
            transform: scale(0.8);
            cursor: pointer;
            background: rgba(60, 60, 60, 0.9);
            border-radius: 10px;
            padding: 0;
            box-sizing: border-box;
            overflow: hidden;
        }

        .mode-slide.active {
            opacity: 1;
            transform: scale(1);
            z-index: 10;
            box-shadow: 0 0 30px rgba(255, 0, 0, 0.7);
        }

        .mode-slide.left {
            transform: translateX(-80%) scale(0.7);
        }

        .mode-slide.right {
            transform: translateX(80%) scale(0.7);
        }

        .mode-icon {
            width: 100%;
            height: 60%;
            object-fit: cover;
            pointer-events: none;
        }

        .mode-name {
            width: 80%;
            height: 20%;
            object-fit: contain;
            pointer-events: none;
            margin: 1vmin 0;
        }

        .carousel-nav {
            display: flex;
            gap: 3vmin;
            margin-top: 3vmin;
            align-items: center;
        }

        .nav-arrow {
            width: 15vmin;
            max-width: 150px;
            cursor: pointer;
            transition: all 0.3s ease;
            object-fit: contain;
            -webkit-user-drag: none;
            user-drag: none;
            pointer-events: auto;
        }

        .nav-arrow:hover {
            transform: scale(1.1);
        }

        .start-mode-button {
            width: 40vmin;
            max-width: 400px;
            min-width: 200px;
            cursor: pointer;
            transition: all 0.3s ease;
            object-fit: contain;
            -webkit-user-drag: none;
            user-drag: none;
            pointer-events: auto;
        }

        .start-mode-button:hover {
            transform: scale(1.05);
        }

        /* Дополнительные UI элементы */
        #modeStats {
            position: absolute;
            top: 50px;
            right: 20px;
            color: white;
            font-size: 20px;
            font-family: 'Arial', sans-serif;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
            z-index: 45;
            display: none;
            pointer-events: none;
            background: rgba(0,0,0,0.5);
            padding: 10px;
            border-radius: 5px;
        }

        #multiplayerInfo {
            position: absolute;
            top: 10px;
            right: 10px;
            color: white;
            font-size: 16px;
            background: rgba(0,0,0,0.7);
            padding: 10px;
            border-radius: 5px;
            display: none;
            z-index: 46;
        }

        .player-status {
            margin: 5px 0;
            padding: 5px;
            border-radius: 3px;
        }

        .player-alive {
            background: rgba(0, 255, 0, 0.3);
        }

        .player-dead {
            background: rgba(255, 0, 0, 0.3);
        }

        .respawn-timer {
            font-size: 12px;
            color: #ffaa00;
        }
    </style>
</head>
<body>
    <!-- Стартовое меню -->
    <div id="startMenu">
        <img src="MenuUi/Logo.png" alt="DOOM" class="logo">
        <div class="menu-buttons">
            <img src="MenuUi/PlayText.png" alt="Играть" class="menu-button" id="playButton">
            <img src="MenuUi/ConnectText.png" alt="Подключиться" class="menu-button" id="connectButton">
            <img src="MenuUi/OptionsText.png" alt="Настройки" class="menu-button" id="optionsButton">
        </div>
        <img src="MenuUi/companyname.png" alt="Company Name" class="company-name">
    </div>

    <!-- Меню подключения -->
    <div id="connectMenu">
        <img src="MenuUi/ConnectText.png" alt="ПОДКЛЮЧЕНИЕ" class="connect-title">
        <input type="text" id="roomCodeInput" class="room-input" placeholder="КОД КОМНАТЫ" maxlength="6">
        <div class="connect-buttons">
            <img src="MenuUi/ConnectText.png" alt="ПОДКЛЮЧИТЬСЯ" class="menu-button" id="joinRoomButton">
            <img src="MenuUi/BackText.png" alt="НАЗАД" class="menu-button" id="backFromConnectButton">
        </div>
    </div>
    
    <!-- Меню выбора режима -->
    <div id="modeSelectMenu">
        <img src="MenuUi/SelectModeText.png" alt="ВЫБОР РЕЖИМА" class="mode-select-title">
        
        <div class="mode-carousel">
            <div class="mode-slide" data-mode="extermination">
                <img src="MenuUi/ModeIcons/ExterminationProtocol.png" alt="Extermination Protocol" class="mode-icon">
                <img src="MenuUi/ModeTexts/ExterminationProtocolText.png" alt="EXTERMINATION PROTOCOL" class="mode-name">
            </div>
            
            <div class="mode-slide" data-mode="straight">
                <img src="MenuUi/ModeIcons/StraightThrough.png" alt="Straight Through" class="mode-icon">
                <img src="MenuUi/ModeTexts/StraightThroughText.png" alt="STRAIGHT THROUGH" class="mode-name">
            </div>
            
            <div class="mode-slide" data-mode="onslaught">
                <img src="MenuUi/ModeIcons/Onslaught.png" alt="Onslaught" class="mode-icon">
                <img src="MenuUi/ModeTexts/OnslaughtText.png" alt="ONSLAUGHT" class="mode-name">
            </div>
        </div>
        
        <div class="carousel-nav">
            <img src="MenuUi/PreviousText.png" alt="Назад" class="nav-arrow" id="prevMode">
            <img src="MenuUi/StartGameText.png" alt="Начать игру" class="start-mode-button" id="startModeButton">
            <img src="MenuUi/NextText.png" alt="Вперед" class="nav-arrow" id="nextMode">
        </div>
        
        <img src="MenuUi/BackText.png" alt="НАЗАД" class="back-button" id="backToMainButton">
    </div>
    
    <!-- Меню настроек -->
    <div id="optionsMenu">
        <img src="MenuUi/OptionsText.png" alt="НАСТРОЙКИ" class="options-title">
        
        <div class="option-item">
            <label>
                Громкость музыки: 
                <input type="range" id="musicVolumeSlider" min="0" max="100" value="50">
            </label>
        </div>
        
        <div class="option-item">
            <label>
                Громкость звуков: 
                <input type="range" id="soundVolumeSlider" min="0" max="100" value="50">
            </label>
        </div>
        
        <div class="option-item">
            <label>
                Чувствительность: 
                <input type="range" id="sensitivitySlider" min="1" max="10" value="5">
            </label>
        </div>
        
        <img src="MenuUi/BackText.png" alt="НАЗАД" class="back-button" id="backButton">
    </div>
    
    <!-- Мобильное управление -->
    <div id="mobileControls">
        <div id="movementJoystick">
            <div class="joystick-base"></div>
            <div class="joystick-stick" id="joystickStick"></div>
        </div>
        
        <!-- Область для поворота камеры -->
        <div id="cameraTouchArea"></div>
        
        <!-- Кнопка стрельбы -->
        <div id="shootButton">FIRE</div>
    </div>
    
    <!-- Оружие -->
    <img id="weapon" src="Guns/DefaultShootGun/Gun.png" alt="Weapon">
    
    <!-- UI Панель с текстом -->
    <div id="uiPanel">
        <div id="hpDisplay">HP: 100</div>
        <div id="ammoDisplay">ПАТРОНЫ: 2/2</div>
        <div id="roomCodeDisplay" style="color: #ffff00; display: none;">КОД: </div>
    </div>
    
    <!-- Мультиплеер информация -->
    <div id="multiplayerInfo">
        <div id="playersList"></div>
    </div>
    
    <!-- Дополнительная статистика для режимов -->
    <div id="modeStats">
        <div id="enemiesKilled">Убито: 0/40</div>
        <div id="waveCounter">Волна: 1</div>
    </div>
    
    <!-- Эффект получения урона -->
    <div id="damageEffect"></div>
    
    <!-- FPS счетчик -->
    <div id="fpsCounter">FPS: 0</div>

    <!-- Подключаем PeerJS -->
    <script src="https://unpkg.com/peerjs@1.4.7/dist/peerjs.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // ЖЕСТКИЙ ЗАПРЕТ КОНТЕКСТНОГО МЕНЮ И ПЕРЕТАСКИВАНИЯ
        document.addEventListener('contextmenu', function(e) {
            e.preventDefault();
            return false;
        });
        
        document.addEventListener('dragstart', function(e) {
            e.preventDefault();
            return false;
        });

        // МУЛЬТИПЛЕЕР СИСТЕМА
        class MultiplayerSystem {
            constructor() {
                this.peer = null;
                this.conn = null;
                this.roomCode = null;
                this.isHost = false;
                this.players = new Map();
                this.connected = false;
                this.playerId = this.generatePlayerId();
            }

            generatePlayerId() {
                return Math.random().toString(36).substring(2, 8);
            }

            generateRoomCode() {
                return Math.random().toString(36).substring(2, 8).toUpperCase();
            }

            async init() {
                try {
                    // Используем бесплатный PeerJS сервер
                    this.peer = new Peer(this.playerId, {
                        host: '0.peerjs.com',
                        port: 443,
                        path: '/',
                        secure: true,
                        config: {
                            iceServers: [
                                { urls: 'stun:stun.l.google.com:19302' },
                                { urls: 'stun:global.stun.twilio.com:3478' }
                            ]
                        }
                    });

                    this.peer.on('open', (id) => {
                        console.log('Peer connected with ID:', id);
                    });

                    this.peer.on('connection', (conn) => {
                        console.log('Player connected:', conn.peer);
                        this.setupConnection(conn);
                    });

                    this.peer.on('error', (err) => {
                        console.error('PeerJS error:', err);
                    });

                } catch (error) {
                    console.error('Failed to initialize multiplayer:', error);
                }
            }

            async createRoom() {
                this.roomCode = this.generateRoomCode();
                this.isHost = true;
                
                // Ждем подключения других игроков
                console.log('Room created with code:', this.roomCode);
                return this.roomCode;
            }

            async joinRoom(roomCode) {
                this.roomCode = roomCode.toUpperCase();
                this.isHost = false;
                
                try {
                    this.conn = this.peer.connect(this.roomCode);
                    this.setupConnection(this.conn);
                    return true;
                } catch (error) {
                    console.error('Failed to join room:', error);
                    return false;
                }
            }

            setupConnection(conn) {
                this.conn = conn;
                
                conn.on('open', () => {
                    console.log('Connected to peer');
                    this.connected = true;
                    
                    // Отправляем информацию о себе
                    this.sendPlayerInfo();
                });

                conn.on('data', (data) => {
                    this.handleNetworkData(data);
                });

                conn.on('close', () => {
                    console.log('Connection closed');
                    this.connected = false;
                });

                conn.on('error', (err) => {
                    console.error('Connection error:', err);
                });
            }

            sendPlayerInfo() {
                if (!this.connected) return;
                
                this.send({
                    type: 'player_info',
                    playerId: this.playerId,
                    position: {
                        x: camera.position.x,
                        y: camera.position.y,
                        z: camera.position.z
                    },
                    rotation: camera.rotation.y,
                    hp: hp,
                    isAlive: hp > 0
                });
            }

            send(data) {
                if (this.conn && this.conn.open) {
                    this.conn.send(data);
                }
            }

            handleNetworkData(data) {
                switch(data.type) {
                    case 'player_info':
                        this.updatePlayer(data.playerId, data);
                        break;
                    case 'player_update':
                        this.updatePlayer(data.playerId, data);
                        break;
                    case 'game_state':
                        if (this.isHost) break;
                        // Синхронизируем состояние игры
                        this.syncGameState(data);
                        break;
                    case 'enemy_update':
                        this.syncEnemy(data.enemyId, data);
                        break;
                    case 'player_shoot':
                        this.playRemoteShoot(data.playerId, data.position);
                        break;
                    case 'player_damage':
                        this.handleRemoteDamage(data.playerId, data.damage);
                        break;
                }
            }

            updatePlayer(playerId, data) {
                if (playerId === this.playerId) return;

                if (!this.players.has(playerId)) {
                    this.createRemotePlayer(playerId, data);
                }

                const player = this.players.get(playerId);
                if (player && player.sprite) {
                    // Плавно интерполируем позицию
                    player.targetPosition = new THREE.Vector3(data.position.x, data.position.y, data.position.z);
                    player.targetRotation = data.rotation;
                    player.hp = data.hp;
                    player.isAlive = data.isAlive;
                    
                    // Обновляем анимацию
                    if (data.isMoving !== undefined) {
                        player.isMoving = data.isMoving;
                    }
                }

                this.updatePlayersUI();
            }

            createRemotePlayer(playerId, data) {
                const sprite = new THREE.Sprite(new THREE.SpriteMaterial({
                    map: this.createPlayerTexture('front', 0),
                    transparent: true,
                    fog: true
                }));

                sprite.position.set(data.position.x, 1.7, data.position.z);
                sprite.scale.set(3, 3, 1);
                scene.add(sprite);

                const player = {
                    id: playerId,
                    sprite: sprite,
                    targetPosition: new THREE.Vector3(data.position.x, data.position.y, data.position.z),
                    targetRotation: data.rotation,
                    hp: data.hp,
                    isAlive: data.isAlive,
                    isMoving: false,
                    animationTimer: 0,
                    currentFrame: 0,
                    direction: 'front',
                    lastPosition: new THREE.Vector3(data.position.x, data.position.y, data.position.z)
                };

                this.players.set(playerId, player);
            }

            createPlayerTexture(direction, frame) {
                const canvas = document.createElement('canvas');
                canvas.width = 64;
                canvas.height = 64;
                const context = canvas.getContext('2d');
                
                const img = new Image();
                img.src = `GameUi/Player/${direction.charAt(0).toUpperCase() + direction.slice(1)}/${frame}.png`;
                
                context.fillStyle = 'transparent';
                context.fillRect(0, 0, 64, 64);
                context.drawImage(img, 0, 0, 64, 64);
                
                return new THREE.CanvasTexture(canvas);
            }

            updateRemotePlayers(deltaTime) {
                for (let [playerId, player] of this.players) {
                    if (!player.sprite) continue;

                    // Интерполяция позиции
                    player.sprite.position.lerp(player.targetPosition, 0.2);
                    player.sprite.rotation.y = player.targetRotation;

                    // Определяем направление движения
                    const moveDelta = new THREE.Vector3();
                    moveDelta.subVectors(player.sprite.position, player.lastPosition);
                    const moveDistance = moveDelta.length();

                    if (moveDistance > 0.01) {
                        player.isMoving = true;
                        
                        // Определяем направление относительно камеры
                        const angle = Math.atan2(moveDelta.x, moveDelta.z);
                        const viewAngle = camera.rotation.y;
                        const relativeAngle = angle - viewAngle;
                        
                        // Нормализуем угол
                        let normalizedAngle = ((relativeAngle + Math.PI) % (2 * Math.PI)) - Math.PI;
                        
                        // Определяем направление анимации
                        if (Math.abs(normalizedAngle) < Math.PI/4) {
                            player.direction = 'back';
                        } else if (Math.abs(normalizedAngle) > 3*Math.PI/4) {
                            player.direction = 'front';
                        } else if (normalizedAngle > 0) {
                            player.direction = 'right';
                        } else {
                            player.direction = 'left';
                        }
                    } else {
                        player.isMoving = false;
                    }

                    // Анимация движения
                    player.animationTimer += deltaTime;
                    if (player.isMoving && player.animationTimer > 0.1) {
                        player.animationTimer = 0;
                        
                        let maxFrames = 4;
                        if (player.direction === 'left' || player.direction === 'right') {
                            maxFrames = 3;
                        }
                        
                        player.currentFrame = (player.currentFrame % maxFrames) + 1;
                        player.sprite.material.map = this.createPlayerTexture(player.direction, player.currentFrame);
                        player.sprite.material.needsUpdate = true;
                    } else if (!player.isMoving && player.currentFrame !== 0) {
                        player.currentFrame = 0;
                        player.sprite.material.map = this.createPlayerTexture(player.direction, 0);
                        player.sprite.material.needsUpdate = true;
                    }

                    player.lastPosition.copy(player.sprite.position);

                    // Визуализация состояния игрока
                    if (!player.isAlive) {
                        player.sprite.material.opacity = 0.5;
                    } else {
                        player.sprite.material.opacity = 1.0;
                    }
                }
            }

            updatePlayersUI() {
                const playersList = document.getElementById('playersList');
                if (!playersList) return;

                let html = '';
                for (let [playerId, player] of this.players) {
                    const statusClass = player.isAlive ? 'player-alive' : 'player-dead';
                    const statusText = player.isAlive ? `HP: ${player.hp}` : 'УМЕР';
                    
                    html += `<div class="player-status ${statusClass}">Игрок ${playerId.substring(0, 4)}: ${statusText}</div>`;
                }

                // Добавляем себя в список
                const selfStatusClass = hp > 0 ? 'player-alive' : 'player-dead';
                const selfStatusText = hp > 0 ? `HP: ${hp}` : 'УМЕР';
                html += `<div class="player-status ${selfStatusClass}">ВЫ: ${selfStatusText}</div>`;

                playersList.innerHTML = html;
            }

            sendPlayerUpdate() {
                if (!this.connected) return;

                const isMoving = moveForward || moveBackward || moveLeft || moveRight;
                
                this.send({
                    type: 'player_update',
                    playerId: this.playerId,
                    position: {
                        x: camera.position.x,
                        y: camera.position.y,
                        z: camera.position.z
                    },
                    rotation: camera.rotation.y,
                    hp: hp,
                    isAlive: hp > 0,
                    isMoving: isMoving
                });
            }

            sendGameState() {
                if (!this.isHost || !this.connected) return;

                const gameState = {
                    type: 'game_state',
                    enemies: enemies.map(enemy => ({
                        id: enemy.id,
                        x: enemy.x,
                        z: enemy.z,
                        health: enemy.health,
                        isAlive: enemy.isAlive
                    })),
                    enemiesKilled: enemiesKilled,
                    currentWave: currentWave
                };

                this.send(gameState);
            }

            syncGameState(data) {
                // Синхронизируем состояние игры с хостом
                enemiesKilled = data.enemiesKilled;
                currentWave = data.currentWave;
                updateUI();
            }

            sendEnemyUpdate(enemy) {
                if (!this.isHost || !this.connected) return;

                this.send({
                    type: 'enemy_update',
                    enemyId: enemy.id,
                    x: enemy.x,
                    z: enemy.z,
                    health: enemy.health,
                    isAlive: enemy.isAlive
                });
            }

            syncEnemy(enemyId, data) {
                if (this.isHost) return;

                // Находим или создаем врага
                let enemy = enemies.find(e => e.id === enemyId);
                if (!enemy && data.isAlive) {
                    // Создаем нового врага
                    enemy = new Enemy(data.x, data.z);
                    enemy.id = enemyId;
                    enemies.push(enemy);
                }

                if (enemy) {
                    enemy.x = data.x;
                    enemy.z = data.z;
                    enemy.health = data.health;
                    enemy.isAlive = data.isAlive;
                    
                    if (enemy.sprite) {
                        enemy.sprite.position.set(data.x, 0.8, data.z);
                        
                        if (!data.isAlive && !enemy.isDying) {
                            enemy.startDeath();
                        }
                    }
                }
            }

            sendShoot() {
                if (!this.connected) return;

                this.send({
                    type: 'player_shoot',
                    playerId: this.playerId,
                    position: {
                        x: camera.position.x,
                        y: camera.position.y,
                        z: camera.position.z
                    }
                });
            }

            playRemoteShoot(playerId, position) {
                // Воспроизводим эффект выстрела другого игрока
                // Можно добавить частицы или звук
                console.log(`Player ${playerId} shooting at`, position);
            }

            sendDamage(damage) {
                if (!this.connected) return;

                this.send({
                    type: 'player_damage',
                    playerId: this.playerId,
                    damage: damage
                });
            }

            handleRemoteDamage(playerId, damage) {
                // Обрабатываем получение урона другим игроком
                console.log(`Player ${playerId} took ${damage} damage`);
            }

            disconnect() {
                if (this.conn) {
                    this.conn.close();
                }
                if (this.peer) {
                    this.peer.destroy();
                }
                this.connected = false;
                
                // Удаляем всех удаленных игроков
                for (let [playerId, player] of this.players) {
                    if (player.sprite) {
                        scene.remove(player.sprite);
                    }
                }
                this.players.clear();
            }
        }

        // Создаем систему мультиплеера
        const multiplayer = new MultiplayerSystem();

        // Система сохранения настроек
        class SettingsManager {
            constructor() {
                this.defaultSettings = {
                    musicVolume: 50,
                    soundVolume: 50,
                    sensitivity: 5
                };
                this.loadSettings();
            }

            loadSettings() {
                try {
                    const saved = localStorage.getItem('doomMazeSettings');
                    if (saved) {
                        const settings = JSON.parse(saved);
                        this.musicVolume = settings.musicVolume || this.defaultSettings.musicVolume;
                        this.soundVolume = settings.soundVolume || this.defaultSettings.soundVolume;
                        this.sensitivity = settings.sensitivity || this.defaultSettings.sensitivity;
                    } else {
                        this.musicVolume = this.defaultSettings.musicVolume;
                        this.soundVolume = this.defaultSettings.soundVolume;
                        this.sensitivity = this.defaultSettings.sensitivity;
                    }
                } catch (e) {
                    console.error('Ошибка загрузки настроек:', e);
                    this.musicVolume = this.defaultSettings.musicVolume;
                    this.soundVolume = this.defaultSettings.soundVolume;
                    this.sensitivity = this.defaultSettings.sensitivity;
                }
            }

            saveSettings() {
                try {
                    const settings = {
                        musicVolume: this.musicVolume,
                        soundVolume: this.soundVolume,
                        sensitivity: this.sensitivity
                    };
                    localStorage.setItem('doomMazeSettings', JSON.stringify(settings));
                } catch (e) {
                    console.error('Ошибка сохранения настроек:', e);
                }
            }

            updateSetting(key, value) {
                if (this.hasOwnProperty(key)) {
                    this[key] = value;
                    this.saveSettings();
                    return true;
                }
                return false;
            }
        }

        // Создаем менеджер настроек
        const settingsManager = new SettingsManager();

        // Переменные для режимов игры
        let currentGameMode = null;
        let enemiesKilled = 0;
        let targetEnemies = 40;
        let currentWave = 1;
        let exitArea = null;
        let waveSpawnTimer = 0;
        let waveEnemiesCount = 0;
        let waveEnemiesKilled = 0;
        let enemiesToSpawn = 0;
        let lastSpawnTime = 0;
        const SPAWN_INTERVAL = 1000;

        // Базовые настройки Three.js
        const scene = new THREE.Scene();
        scene.fog = new THREE.Fog(0x87CEEB, 20, 50);
        
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 50);
        
        const renderer = new THREE.WebGLRenderer({ 
            antialias: true,
            powerPreference: "high-performance"
        });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setClearColor(0x87CEEB);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        document.body.appendChild(renderer.domElement);

        // Параметры лабиринта
        const CELL_SIZE = 8;
        const WALL_HEIGHT = 8;
        const WALL_THICKNESS = 0.3;

        // Текстуры
        const textureLoader = new THREE.TextureLoader();
        let wallTexture, floorTexture, roofTexture;

        // Загрузка текстур
        function loadTextures() {
            return new Promise((resolve) => {
                let texturesLoaded = 0;
                const totalTextures = 3;

                function onTextureLoad() {
                    texturesLoaded++;
                    if (texturesLoaded === totalTextures) {
                        resolve();
                    }
                }

                wallTexture = textureLoader.load('Textures/WallTex.jpg', onTextureLoad);
                floorTexture = textureLoader.load('Textures/FloorTex.jpg', onTextureLoad);
                roofTexture = textureLoader.load('Textures/RoofTex.jpg', onTextureLoad);

                // Настройки текстур
                [wallTexture, floorTexture, roofTexture].forEach(texture => {
                    if (texture) {
                        texture.wrapS = texture.wrapT = THREE.RepeatWrapping;
                        texture.repeat.set(1, 1);
                        texture.minFilter = THREE.LinearFilter;
                        texture.magFilter = THREE.LinearFilter;
                    }
                });
            });
        }

        // Создаем материалы с текстурами
        function createMaterials() {
            const wallMaterial = wallTexture ? 
                new THREE.MeshLambertMaterial({ map: wallTexture, fog: true }) :
                new THREE.MeshLambertMaterial({ color: 0x8B4513, fog: true });
            
            const floorMaterial = floorTexture ? 
                new THREE.MeshLambertMaterial({ map: floorTexture, fog: true }) :
                new THREE.MeshLambertMaterial({ color: 0x90EE90, fog: true });
            
            const roofMaterial = roofTexture ? 
                new THREE.MeshLambertMaterial({ map: roofTexture, fog: true }) :
                new THREE.MeshLambertMaterial({ color: 0xCCCCCC, fog: true });
            
            return { wallMaterial, floorMaterial, roofMaterial };
        }

        // Генератор лабиринта
        class MazeGenerator {
            constructor(width, height, mode = 'extermination') {
                this.width = width;
                this.height = height;
                this.mode = mode;
                this.maze = this.generateMazeForMode();
            }

            generateMazeForMode() {
                if (this.mode === 'straight') {
                    return this.generateRealMaze();
                } else {
                    return this.generateMazeWithMultiplePaths();
                }
            }

            generateRealMaze() {
                let maze = Array(this.height).fill().map(() => Array(this.width).fill(1));
                this.depthFirstMaze(maze, 1, 1);
                maze[1][1] = 0;
                maze[this.height-2][this.width-2] = 0;
                this.addExtraPassages(maze, 0.1);
                return maze;
            }

            depthFirstMaze(maze, startX, startY) {
                let stack = [[startX, startY]];
                maze[startY][startX] = 0;
                const directions = [[0, 2], [2, 0], [0, -2], [-2, 0]];
                
                while (stack.length > 0) {
                    let [x, y] = stack[stack.length - 1];
                    let neighbors = [];
                    
                    for (let [dx, dy] of directions) {
                        let nx = x + dx, ny = y + dy;
                        if (nx > 0 && nx < this.width - 1 && ny > 0 && ny < this.height - 1 && maze[ny][nx] === 1) {
                            let valid = true;
                            for (let [ddx, ddy] of [[0,1],[1,0],[0,-1],[-1,0]]) {
                                let nnx = nx + ddx, nny = ny + ddy;
                                if (nnx !== x && nny !== y && maze[nny] && maze[nny][nnx] === 0) {
                                    valid = false;
                                    break;
                                }
                            }
                            if (valid) neighbors.push([dx, dy, nx, ny]);
                        }
                    }
                    
                    if (neighbors.length > 0) {
                        let [dx, dy, nx, ny] = neighbors[Math.floor(Math.random() * neighbors.length)];
                        maze[y + dy/2][x + dx/2] = 0;
                        maze[ny][nx] = 0;
                        stack.push([nx, ny]);
                    } else {
                        stack.pop();
                    }
                }
            }

            addExtraPassages(maze, probability) {
                for (let y = 1; y < this.height - 1; y++) {
                    for (let x = 1; x < this.width - 1; x++) {
                        if (maze[y][x] === 1 && Math.random() < probability) {
                            let wallCount = 0;
                            for (let [dx, dy] of [[0,1],[1,0],[0,-1],[-1,0]]) {
                                if (maze[y+dy] && maze[y+dy][x+dx] === 1) wallCount++;
                            }
                            if (wallCount >= 3) maze[y][x] = 0;
                        }
                    }
                }
            }

            generateMazeWithMultiplePaths() {
                let maze = Array(this.height).fill().map(() => Array(this.width).fill(1));
                const paths = [];
                const numPaths = 3;
                
                for (let i = 0; i < numPaths; i++) {
                    let startX = 1 + Math.floor(Math.random() * (this.width - 3));
                    let startY = 1 + Math.floor(Math.random() * (this.height - 3));
                    paths.push(this.generatePath(maze, startX, startY));
                }
                
                this.connectPaths(maze, paths);
                this.addRandomPassages(maze);
                return maze;
            }

            generatePath(maze, startX, startY) {
                let x = startX, y = startY;
                maze[y][x] = 0;
                let path = [[x, y]];
                let directions = [[0, 2], [2, 0], [0, -2], [-2, 0]];
                let stack = [[x, y]];
                
                while (stack.length > 0) {
                    let [cx, cy] = stack[stack.length - 1];
                    let possibleDirs = directions.filter(([dx, dy]) => {
                        let nx = cx + dx, ny = cy + dy;
                        return nx > 0 && nx < this.width - 1 && ny > 0 && ny < this.height - 1 && maze[ny][nx] === 1;
                    });
                    
                    if (possibleDirs.length > 0) {
                        let [dx, dy] = possibleDirs[Math.floor(Math.random() * possibleDirs.length)];
                        let nx = cx + dx, ny = cy + dy;
                        maze[cy + dy/2][cx + dx/2] = 0;
                        maze[ny][nx] = 0;
                        path.push([nx, ny]);
                        stack.push([nx, ny]);
                    } else {
                        stack.pop();
                    }
                }
                return path;
            }

            connectPaths(maze, paths) {
                for (let i = 0; i < paths.length - 1; i++) {
                    const connectionPoints = 2;
                    for (let j = 0; j < connectionPoints; j++) {
                        const point1 = paths[i][Math.floor(Math.random() * paths[i].length)];
                        const point2 = paths[i+1][Math.floor(Math.random() * paths[i+1].length)];
                        this.createPassage(maze, point1, point2);
                    }
                }
            }

            createPassage(maze, [x1, y1], [x2, y2]) {
                let x = x1, y = y1;
                while (x !== x2 || y !== y2) {
                    if (Math.random() > 0.5 && x !== x2) {
                        x += x < x2 ? 1 : -1;
                    } else if (y !== y2) {
                        y += y < y2 ? 1 : -1;
                    }
                    if (x > 0 && x < this.width - 1 && y > 0 && y < this.height - 1) {
                        maze[y][x] = 0;
                    }
                }
            }

            addRandomPassages(maze) {
                const numExtraPassages = Math.floor(this.width * this.height * 0.1);
                for (let i = 0; i < numExtraPassages; i++) {
                    const x = 1 + Math.floor(Math.random() * (this.width - 2));
                    const y = 1 + Math.floor(Math.random() * (this.height - 2));
                    if (maze[y][x] === 1) {
                        const neighbors = [[x-1, y], [x+1, y], [x, y-1], [x, y+1]]
                            .filter(([nx, ny]) => nx >= 0 && nx < this.width && ny >= 0 && ny < this.height);
                        const passageNeighbors = neighbors.filter(([nx, ny]) => maze[ny][nx] === 0);
                        if (passageNeighbors.length >= 2) maze[y][x] = 0;
                    }
                }
            }

            getMaze() {
                return this.maze;
            }
        }

        // Создаем лабиринт
        let mazeGen = null;
        let maze = null;

        // Освещение
        const ambientLight = new THREE.AmbientLight(0xffffff, 1.0);
        scene.add(ambientLight);
        
        const directionalLight1 = new THREE.DirectionalLight(0xffffff, 0.8);
        directionalLight1.position.set(50, 100, 50);
        scene.add(directionalLight1);
        
        const directionalLight2 = new THREE.DirectionalLight(0xffffff, 0.6);
        directionalLight2.position.set(-50, 80, -50);
        scene.add(directionalLight2);

        // Создание сцены
        function createScene(materials) {
            while(scene.children.length > 0){ 
                scene.remove(scene.children[0]); 
            }
            
            scene.add(ambientLight);
            scene.add(directionalLight1);
            scene.add(directionalLight2);
            
            createFloor(materials.floorMaterial);
            createRoof(materials.roofMaterial);
            createMazeWalls(materials.wallMaterial);
        }

        function createFloor(floorMaterial) {
            const floorWidth = maze[0].length * CELL_SIZE;
            const floorHeight = maze.length * CELL_SIZE;
            const floorGeometry = new THREE.PlaneGeometry(floorWidth, floorHeight);
            const floor = new THREE.Mesh(floorGeometry, floorMaterial);
            floor.rotation.x = -Math.PI / 2;
            floor.position.y = -1;
            scene.add(floor);
        }

        function createRoof(roofMaterial) {
            const roofWidth = maze[0].length * CELL_SIZE;
            const roofHeight = maze.length * CELL_SIZE;
            const roofGeometry = new THREE.PlaneGeometry(roofWidth, roofHeight);
            const roof = new THREE.Mesh(roofGeometry, roofMaterial);
            roof.rotation.x = Math.PI / 2;
            roof.position.y = WALL_HEIGHT - 1;
            scene.add(roof);
        }

        function createMazeWalls(wallMaterial) {
            const wallGroup = new THREE.Group();
            
            for (let y = 0; y < maze.length; y++) {
                for (let x = 0; x < maze[y].length - 1; x++) {
                    if (maze[y][x] === 1 || maze[y][x+1] === 1) {
                        if (maze[y][x] !== maze[y][x+1]) {
                            const wallGeometry = new THREE.BoxGeometry(WALL_THICKNESS, WALL_HEIGHT, CELL_SIZE);
                            const wall = new THREE.Mesh(wallGeometry, wallMaterial);
                            wall.position.set(
                                (x + 0.5 - maze[0].length/2) * CELL_SIZE, 
                                WALL_HEIGHT/2 - 1,
                                (y - maze.length/2) * CELL_SIZE
                            );
                            wallGroup.add(wall);
                        }
                    }
                }
            }

            for (let y = 0; y < maze.length - 1; y++) {
                for (let x = 0; x < maze[y].length; x++) {
                    if (maze[y][x] === 1 || maze[y+1][x] === 1) {
                        if (maze[y][x] !== maze[y+1][x]) {
                            const wallGeometry = new THREE.BoxGeometry(CELL_SIZE, WALL_HEIGHT, WALL_THICKNESS);
                            const wall = new THREE.Mesh(wallGeometry, wallMaterial);
                            wall.position.set(
                                (x - maze[0].length/2) * CELL_SIZE, 
                                WALL_HEIGHT/2 - 1,
                                (y + 0.5 - maze.length/2) * CELL_SIZE
                            );
                            wallGroup.add(wall);
                        }
                    }
                }
            }

            scene.add(wallGroup);
        }

        // Позиция игрока
        function findRandomStartPosition() {
            let freeCells = [];
            for (let y = 1; y < maze.length - 1; y++) {
                for (let x = 1; x < maze[y].length - 1; x++) {
                    if (maze[y][x] === 0) freeCells.push({x, y});
                }
            }
            
            if (freeCells.length > 0) {
                const randomCell = freeCells[Math.floor(Math.random() * freeCells.length)];
                return {
                    x: (randomCell.x - maze[0].length/2) * CELL_SIZE,
                    z: (randomCell.y - maze.length/2) * CELL_SIZE
                };
            }
            
            return {
                x: (-maze[0].length/2 + 1) * CELL_SIZE,
                z: (-maze.length/2 + 1) * CELL_SIZE
            };
        }

        let startPos = { x: 0, z: 0 };

        // Переменные управления
        let moveForward = false;
        let moveBackward = false;
        let moveLeft = false;
        let moveRight = false;
        
        let yaw = 0;
        let pitch = 0;
        const PI_2 = Math.PI / 2;

        // Настройки чувствительности
        let mouseSensitivity = settingsManager.sensitivity * 0.0004;

        // Аудио система
        let musicVolume = settingsManager.musicVolume / 100;
        let soundVolume = settingsManager.soundVolume / 100;
        let currentMusic = null;
        let musicTracks = [];
        let currentTrackIndex = 0;
        let musicStarted = false;

        // Звуковые эффекты
        let shootSound = null;
        let reloadSound = null;
        let playerHitSound = null;
        let impDamageSound1 = null;
        let impDamageSound2 = null;
        let impDeathSound1 = null;
        let impDeathSound2 = null;
        let impDeathSound3 = null;

        // Оружие
        const weapon = document.getElementById('weapon');
        let isShooting = false;
        let isReloading = false;
        let canShoot = true;
        let ammo = 2;
        let maxAmmo = 2;
        let hp = 100;
        
        // Переменные для автоматической стрельбы
        let isMouseDown = false;
        let autoShootInterval = null;
        let lastShootTime = 0;
        const SHOOT_DELAY = 300;

        // Предзагрузка изображений оружия
        const gunImages = {
            normal: 'Guns/DefaultShootGun/Gun.png',
            shoot1: 'Guns/DefaultShootGun/GunSh1.png',
            shoot2: 'Guns/DefaultShootGun/GunSh2.png',
            reload1: 'Guns/DefaultShootGun/GunKD1.png',
            reload2: 'Guns/DefaultShootGun/GunKD2.png',
            reload3: 'Guns/DefaultShootGun/GunKD3.png'
        };

        function preloadWeaponImages() {
            Object.values(gunImages).forEach(src => {
                const img = new Image();
                img.src = src;
            });
        }

        // Инициализация аудио системы
        function initAudio() {
            shootSound = new Audio('Sounds/Shoot.mp3');
            reloadSound = new Audio('Sounds/Reload.mp3');
            playerHitSound = new Audio('Sounds/PlayerHit.mp3');
            
            impDamageSound1 = new Audio('Sounds/Imp/ImpDamage.mp3');
            impDamageSound2 = new Audio('Sounds/Imp/ImpDamage1.mp3');
            impDeathSound1 = new Audio('Sounds/Imp/ImpDeath.mp3');
            impDeathSound2 = new Audio('Sounds/Imp/ImpDeath1.mp3');
            impDeathSound3 = new Audio('Sounds/Imp/ImpDeath2.mp3');
            
            // Настраиваем звуковые эффекты
            [shootSound, reloadSound, playerHitSound, impDamageSound1, impDamageSound2, 
             impDeathSound1, impDeathSound2, impDeathSound3].forEach(sound => {
                if (sound) sound.volume = soundVolume;
            });
            
            musicTracks = [
                'Sounds/MenuMusic.mp3',
                'Sounds/MenuMusic1.mp3',
                'Sounds/MenuMusic2.mp3'
            ];
            
            currentTrackIndex = Math.floor(Math.random() * musicTracks.length);
        }

        function playNextTrack() {
            if (musicTracks.length === 0) return;
            
            if (currentMusic) {
                currentMusic.pause();
                currentMusic.currentTime = 0;
                currentMusic.removeEventListener('ended', playNextTrack);
            }
            
            currentTrackIndex = (currentTrackIndex + 1) % musicTracks.length;
            currentMusic = new Audio(musicTracks[currentTrackIndex]);
            currentMusic.volume = musicVolume;
            currentMusic.loop = false;
            currentMusic.addEventListener('ended', playNextTrack);
            
            const playPromise = currentMusic.play();
            if (playPromise !== undefined) {
                playPromise.then(() => {
                    musicStarted = true;
                }).catch(error => {
                    document.addEventListener('click', startMusicOnInteraction, { once: true });
                    document.addEventListener('touchstart', startMusicOnInteraction, { once: true });
                });
            }
        }

        function startMusic() {
            if (musicStarted) return;
            playNextTrack();
        }

        function startMusicOnInteraction() {
            if (!musicStarted) startMusic();
        }

        function updateVolumes() {
            if (currentMusic) currentMusic.volume = musicVolume;
            [shootSound, reloadSound, playerHitSound, impDamageSound1, impDamageSound2, 
             impDeathSound1, impDeathSound2, impDeathSound3].forEach(sound => {
                if (sound) sound.volume = soundVolume;
            });
        }

        // Обновление UI
        function updateUI() {
            document.getElementById('hpDisplay').textContent = `HP: ${Math.round(hp)}`;
            document.getElementById('ammoDisplay').textContent = `ПАТРОНЫ: ${ammo}/${maxAmmo}`;
            
            if (currentGameMode === 'extermination') {
                document.getElementById('enemiesKilled').textContent = `Убито: ${enemiesKilled}/${targetEnemies}`;
                document.getElementById('waveCounter').style.display = 'none';
            } else if (currentGameMode === 'onslaught') {
                document.getElementById('enemiesKilled').textContent = `Убито: ${enemiesKilled}`;
                document.getElementById('waveCounter').textContent = `Волна: ${currentWave}`;
                document.getElementById('waveCounter').style.display = 'block';
            } else {
                document.getElementById('enemiesKilled').style.display = 'none';
                document.getElementById('waveCounter').style.display = 'none';
            }

            // Обновляем UI мультиплеера
            multiplayer.updatePlayersUI();
        }

        // Анимация выстрела
        function playShootAnimation() {
            if (!canShoot || isReloading || isShooting || ammo <= 0) return;
            
            isShooting = true;
            canShoot = false;
            ammo--;
            updateUI();
            
            weapon.src = gunImages.shoot1;
            
            if (shootSound) {
                shootSound.currentTime = 0;
                shootSound.play().catch(e => console.log('Не удалось воспроизвести звук выстрела'));
            }
            
            // Отправляем информацию о выстреле в мультиплеере
            multiplayer.sendShoot();
            
            checkEnemyHit();
            
            setTimeout(() => {
                if (!isShooting) return;
                weapon.src = gunImages.shoot2;
            }, 50);
            
            setTimeout(() => {
                if (!isShooting) return;
                weapon.src = gunImages.normal;
                isShooting = false;
                
                if (ammo <= 0) {
                    playReloadAnimation();
                } else {
                    setTimeout(() => {
                        canShoot = true;
                    }, 300);
                }
            }, 150);
        }

        // Анимация перезарядки
        function playReloadAnimation() {
            if (isReloading || ammo >= maxAmmo) return;
            
            isReloading = true;
            canShoot = false;
            
            if (reloadSound) {
                reloadSound.currentTime = 0;
                reloadSound.play().catch(e => console.log('Не удалось воспроизвести звук перезарядки'));
            }
            
            setTimeout(() => {
                if (!isReloading) return;
                weapon.src = gunImages.reload1;
            }, 100);
            
            setTimeout(() => {
                if (!isReloading) return;
                weapon.src = gunImages.reload2;
            }, 300);
            
            setTimeout(() => {
                if (!isReloading) return;
                weapon.src = gunImages.reload3;
            }, 500);
            
            setTimeout(() => {
                if (!isReloading) return;
                weapon.src = gunImages.normal;
                ammo = maxAmmo;
                isReloading = false;
                canShoot = true;
                updateUI();
            }, 700);
        }

        function startAutoShoot() {
            if (autoShootInterval) return;
            
            autoShootInterval = setInterval(() => {
                const currentTime = Date.now();
                if (currentTime - lastShootTime >= SHOOT_DELAY) {
                    playShootAnimation();
                    lastShootTime = currentTime;
                }
            }, 100);
        }

        function stopAutoShoot() {
            if (autoShootInterval) {
                clearInterval(autoShootInterval);
                autoShootInterval = null;
            }
        }

        // FPS счетчик
        const fpsCounter = document.getElementById('fpsCounter');
        let frameCount = 0;
        let lastTime = performance.now();
        let fps = 0;

        // УПРАВЛЕНИЕ
        let activeTouches = new Map();
        let isShootingTouch = false;
        let shootTouchId = null;
        let lastCameraTouchX = 0;
        let lastCameraTouchY = 0;

        // Инициализация управления
        function initControls() {
            // Джойстик для мобильных устройств
            const joystickStick = document.getElementById('joystickStick');
            const joystickBase = document.getElementById('movementJoystick');
            
            let baseRect = joystickBase.getBoundingClientRect();
            const baseCenterX = baseRect.left + baseRect.width / 2;
            const baseCenterY = baseRect.top + baseRect.height / 2;
            const maxDistance = baseRect.width / 3;

            function updateJoystick(touch) {
                const touchX = touch.clientX;
                const touchY = touch.clientY;
                
                const deltaX = touchX - baseCenterX;
                const deltaY = touchY - baseCenterY;
                const distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);
                
                let stickX = deltaX;
                let stickY = deltaY;
                
                if (distance > maxDistance) {
                    const angle = Math.atan2(deltaY, deltaX);
                    stickX = Math.cos(angle) * maxDistance;
                    stickY = Math.sin(angle) * maxDistance;
                }
                
                joystickStick.style.transform = `translate(${stickX}px, ${stickY}px)`;
                
                const normalizedX = stickX / maxDistance;
                const normalizedY = stickY / maxDistance;
                
                moveForward = normalizedY < -0.3;
                moveBackward = normalizedY > 0.3;
                moveLeft = normalizedX < -0.3;
                moveRight = normalizedX > 0.3;
            }

            // Обработка событий джойстика
            joystickBase.addEventListener('touchstart', (e) => {
                e.preventDefault();
                const touch = e.changedTouches[0];
                const rect = joystickBase.getBoundingClientRect();
                const touchX = touch.clientX;
                const touchY = touch.clientY;
                
                if (touchX >= rect.left && touchX <= rect.right && 
                    touchY >= rect.top && touchY <= rect.bottom) {
                    activeTouches.set(touch.identifier, { 
                        type: 'joystick', 
                        element: joystickBase
                    });
                    updateJoystick(touch);
                }
            });

            // Область для поворота камеры
            const cameraArea = document.getElementById('cameraTouchArea');
            const shootButton = document.getElementById('shootButton');

            cameraArea.addEventListener('touchstart', (e) => {
                e.preventDefault();
                const touch = e.changedTouches[0];
                
                const shootRect = shootButton.getBoundingClientRect();
                const touchX = touch.clientX;
                const touchY = touch.clientY;
                
                if (!(touchX >= shootRect.left && touchX <= shootRect.right && 
                      touchY >= shootRect.top && touchY <= shootRect.bottom)) {
                    activeTouches.set(touch.identifier, { 
                        type: 'camera', 
                        element: cameraArea,
                        lastX: touch.clientX,
                        lastY: touch.clientY
                    });
                    lastCameraTouchX = touch.clientX;
                    lastCameraTouchY = touch.clientY;
                }
            });

            // Кнопка стрельбы
            shootButton.addEventListener('touchstart', (e) => {
                e.preventDefault();
                const touch = e.changedTouches[0];
                
                shootTouchId = touch.identifier;
                isShootingTouch = true;
                lastCameraTouchX = touch.clientX;
                lastCameraTouchY = touch.clientY;
                
                playShootAnimation();
            });

            shootButton.addEventListener('touchend', (e) => {
                e.preventDefault();
                for (let touch of e.changedTouches) {
                    if (touch.identifier === shootTouchId) {
                        isShootingTouch = false;
                        shootTouchId = null;
                        break;
                    }
                }
            });

            // Общие обработчики касаний
            document.addEventListener('touchmove', (e) => {
                e.preventDefault();
                
                for (let touch of e.touches) {
                    const touchData = activeTouches.get(touch.identifier);
                    
                    if (touchData && touchData.type === 'joystick') {
                        updateJoystick(touch);
                    } else if (touchData && touchData.type === 'camera') {
                        if (touchData.lastX && touchData.lastY) {
                            const deltaX = touch.clientX - touchData.lastX;
                            const deltaY = touch.clientY - touchData.lastY;
                            
                            yaw -= deltaX * mouseSensitivity * 2;
                            pitch -= deltaY * mouseSensitivity * 2;
                            pitch = Math.max(-PI_2, Math.min(PI_2, pitch));
                        }
                        
                        touchData.lastX = touch.clientX;
                        touchData.lastY = touch.clientY;
                    }
                    
                    if (touch.identifier === shootTouchId && isShootingTouch) {
                        const deltaX = touch.clientX - lastCameraTouchX;
                        const deltaY = touch.clientY - lastCameraTouchY;
                        
                        yaw -= deltaX * mouseSensitivity * 1.5;
                        pitch -= deltaY * mouseSensitivity * 1.5;
                        pitch = Math.max(-PI_2, Math.min(PI_2, pitch));
                        
                        lastCameraTouchX = touch.clientX;
                        lastCameraTouchY = touch.clientY;
                    }
                }
            });

            document.addEventListener('touchend', (e) => {
                for (let touch of e.changedTouches) {
                    const touchData = activeTouches.get(touch.identifier);
                    if (touchData) {
                        if (touchData.type === 'joystick') {
                            joystickStick.style.transform = 'translate(0, 0)';
                            moveForward = moveBackward = moveLeft = moveRight = false;
                        }
                        activeTouches.delete(touch.identifier);
                    }
                    
                    if (touch.identifier === shootTouchId) {
                        isShootingTouch = false;
                        shootTouchId = null;
                    }
                }
            });

            // Управление для ПК
            window.addEventListener('keydown', (event) => {
                if (document.getElementById('startMenu').style.display === 'none' &&
                    document.getElementById('optionsMenu').style.display === 'none' &&
                    document.getElementById('modeSelectMenu').style.display === 'none') {
                    switch(event.code) {
                        case 'KeyW': moveForward = true; break;
                        case 'KeyS': moveBackward = true; break;
                        case 'KeyA': moveLeft = true; break;
                        case 'KeyD': moveRight = true; break;
                    }
                }
            });
            
            window.addEventListener('keyup', (event) => {
                if (document.getElementById('startMenu').style.display === 'none' &&
                    document.getElementById('optionsMenu').style.display === 'none' &&
                    document.getElementById('modeSelectMenu').style.display === 'none') {
                    switch(event.code) {
                        case 'KeyW': moveForward = false; break;
                        case 'KeyS': moveBackward = false; break;
                        case 'KeyA': moveLeft = false; break;
                        case 'KeyD': moveRight = false; break;
                    }
                }
            });

            // Мышь для ПК
            document.addEventListener('mousedown', (e) => {
                if (e.button === 0 && 
                    document.getElementById('startMenu').style.display === 'none' &&
                    document.getElementById('optionsMenu').style.display === 'none' &&
                    document.getElementById('modeSelectMenu').style.display === 'none') {
                    e.preventDefault();
                    isMouseDown = true;
                    playShootAnimation();
                    startAutoShoot();
                }
            });

            document.addEventListener('mouseup', (e) => {
                if (e.button === 0) {
                    isMouseDown = false;
                    stopAutoShoot();
                }
            });

            document.addEventListener('mousemove', (event) => {
                if (document.getElementById('startMenu').style.display === 'none' &&
                    document.getElementById('optionsMenu').style.display === 'none' &&
                    document.getElementById('modeSelectMenu').style.display === 'none' && 
                    document.pointerLockElement === renderer.domElement) {
                    yaw -= event.movementX * mouseSensitivity;
                    pitch -= event.movementY * mouseSensitivity;
                    pitch = Math.max(-PI_2, Math.min(PI_2, pitch));
                }
            });

            // Перезарядка по R
            document.addEventListener('keydown', (e) => {
                if (e.code === 'KeyR' && 
                    document.getElementById('startMenu').style.display === 'none' &&
                    document.getElementById('optionsMenu').style.display === 'none' &&
                    document.getElementById('modeSelectMenu').style.display === 'none') {
                    if (!isReloading && ammo < maxAmmo) {
                        playReloadAnimation();
                    }
                }
            });

            renderer.domElement.addEventListener('click', () => {
                if (document.getElementById('startMenu').style.display === 'none' &&
                    document.getElementById('optionsMenu').style.display === 'none' &&
                    document.getElementById('modeSelectMenu').style.display === 'none') {
                    renderer.domElement.requestPointerLock();
                }
            });

            window.addEventListener('blur', () => {
                activeTouches.clear();
                joystickStick.style.transform = 'translate(0, 0)';
                moveForward = moveBackward = moveLeft = moveRight = false;
                isShootingTouch = false;
                shootTouchId = null;
                stopAutoShoot();
                isMouseDown = false;
            });
        }

        // Проверка коллизий
        function checkCollision(newX, newZ) {
            const playerRadius = 0.3;
            const points = [
                [newX - playerRadius, newZ],
                [newX + playerRadius, newZ],
                [newX, newZ - playerRadius],
                [newX, newZ + playerRadius]
            ];
            
            for (let [px, pz] of points) {
                const mazeX = Math.round((px / CELL_SIZE) + maze[0].length/2);
                const mazeZ = Math.round((pz / CELL_SIZE) + maze.length/2);
                
                if (mazeZ >= 0 && mazeZ < maze.length && 
                    mazeX >= 0 && mazeX < maze[0].length) {
                    if (maze[mazeZ][mazeX] === 1) {
                        return true;
                    }
                } else {
                    return true;
                }
            }
            
            return false;
        }

        // СИСТЕМА НАВИГАЦИИ ДЛЯ ВРАГОВ
        class NavigationSystem {
            constructor() {
                this.nodes = [];
                this.edges = [];
                this.generateNavigationGraph();
            }
            
            generateNavigationGraph() {
                for (let y = 0; y < maze.length; y++) {
                    for (let x = 0; x < maze[y].length; x++) {
                        if (maze[y][x] === 0) {
                            const worldX = (x - maze[0].length/2) * CELL_SIZE;
                            const worldZ = (y - maze.length/2) * CELL_SIZE;
                            
                            this.nodes.push({
                                x: worldX,
                                z: worldZ,
                                id: this.nodes.length
                            });
                        }
                    }
                }
                
                for (let i = 0; i < this.nodes.length; i++) {
                    const node = this.nodes[i];
                    
                    for (let j = 0; j < this.nodes.length; j++) {
                        if (i === j) continue;
                        
                        const otherNode = this.nodes[j];
                        const dx = otherNode.x - node.x;
                        const dz = otherNode.z - node.z;
                        const distance = Math.sqrt(dx * dx + dz * dz);
                        
                        if (distance <= CELL_SIZE * 1.5) {
                            const midX = (node.x + otherNode.x) / 2;
                            const midZ = (node.z + otherNode.z) / 2;
                            
                            const mazeX = Math.round((midX / CELL_SIZE) + maze[0].length/2);
                            const mazeZ = Math.round((midZ / CELL_SIZE) + maze.length/2);
                            
                            if (mazeZ >= 0 && mazeZ < maze.length && 
                                mazeX >= 0 && mazeX < maze[0].length &&
                                maze[mazeZ][mazeX] === 0) {
                                
                                this.edges.push({
                                    from: node.id,
                                    to: otherNode.id,
                                    distance: distance
                                });
                            }
                        }
                    }
                }
            }
            
            findPath(startX, startZ, targetX, targetZ) {
                const startNode = this.findNearestNode(startX, startZ);
                const targetNode = this.findNearestNode(targetX, targetZ);
                
                if (!startNode || !targetNode) return null;
                
                const openSet = [startNode];
                const closedSet = new Set();
                const cameFrom = new Map();
                const gScore = new Map();
                const fScore = new Map();
                
                gScore.set(startNode.id, 0);
                fScore.set(startNode.id, this.heuristic(startNode, targetNode));
                
                while (openSet.length > 0) {
                    let current = openSet[0];
                    let currentIndex = 0;
                    
                    for (let i = 1; i < openSet.length; i++) {
                        if (fScore.get(openSet[i].id) < fScore.get(current.id)) {
                            current = openSet[i];
                            currentIndex = i;
                        }
                    }
                    
                    if (current.id === targetNode.id) {
                        return this.reconstructPath(cameFrom, current);
                    }
                    
                    openSet.splice(currentIndex, 1);
                    closedSet.add(current.id);
                    
                    const neighbors = this.getNeighbors(current);
                    
                    for (let neighbor of neighbors) {
                        if (closedSet.has(neighbor.id)) continue;
                        
                        const tentativeGScore = gScore.get(current.id) + this.getDistance(current, neighbor);
                        
                        if (!openSet.includes(neighbor)) {
                            openSet.push(neighbor);
                        } else if (tentativeGScore >= gScore.get(neighbor.id)) {
                            continue;
                        }
                        
                        cameFrom.set(neighbor.id, current);
                        gScore.set(neighbor.id, tentativeGScore);
                        fScore.set(neighbor.id, gScore.get(neighbor.id) + this.heuristic(neighbor, targetNode));
                    }
                }
                
                return null;
            }
            
            findNearestNode(x, z) {
                let nearestNode = null;
                let minDistance = Infinity;
                
                for (let node of this.nodes) {
                    const dx = node.x - x;
                    const dz = node.z - z;
                    const distance = Math.sqrt(dx * dx + dz * dz);
                    
                    if (distance < minDistance) {
                        minDistance = distance;
                        nearestNode = node;
                    }
                }
                
                return nearestNode;
            }
            
            getNeighbors(node) {
                const neighbors = [];
                
                for (let edge of this.edges) {
                    if (edge.from === node.id) {
                        const neighbor = this.nodes.find(n => n.id === edge.to);
                        if (neighbor) neighbors.push(neighbor);
                    }
                }
                
                return neighbors;
            }
            
            getDistance(nodeA, nodeB) {
                const dx = nodeA.x - nodeB.x;
                const dz = nodeA.z - nodeB.z;
                return Math.sqrt(dx * dx + dz * dz);
            }
            
            heuristic(nodeA, nodeB) {
                return this.getDistance(nodeA, nodeB);
            }
            
            reconstructPath(cameFrom, current) {
                const path = [current];
                
                while (cameFrom.has(current.id)) {
                    current = cameFrom.get(current.id);
                    path.unshift(current);
                }
                
                return path;
            }
        }

        // Создаем систему навигации
        let navigationSystem = null;

        // КЛАСС ВРАГА
        class Enemy {
            constructor(x, z) {
                this.id = Math.random().toString(36).substring(2, 9);
                this.x = x;
                this.z = z;
                this.health = 3;
                this.speed = 9.0;
                this.attackRange = 2.0;
                this.attackCooldown = 0;
                this.fireballCooldown = 0;
                this.isAlive = true;
                this.spriteFrame = 0;
                this.animationTimer = 0;
                this.lastPlayerX = 0;
                this.lastPlayerZ = 0;
                this.path = [];
                this.currentPathIndex = 0;
                this.pathUpdateTimer = 0;
                this.isDying = false;
                this.deathFrame = 0;
                this.deathTimer = 0;
                this.stuckTimer = 0;
                this.lastX = x;
                this.lastZ = z;
                this.avoidanceForce = new THREE.Vector2(0, 0);
                this.teleportTimer = 0;
                this.lastDistanceToPlayer = 0;
                
                // Создаем спрайт врага
                this.sprite = new THREE.Sprite(new THREE.SpriteMaterial({
                    map: this.createEnemyTexture(),
                    transparent: true,
                    fog: true
                }));
                
                this.sprite.position.set(this.x, 0.8, this.z);
                this.sprite.scale.set(4.5, 4.5, 1);
                scene.add(this.sprite);
            }
            
            createEnemyTexture() {
                const canvas = document.createElement('canvas');
                canvas.width = 64;
                canvas.height = 64;
                const context = canvas.getContext('2d');
                
                const img = new Image();
                img.src = 'GameUi/Enemy/Imp/Front/1.png';
                
                context.fillStyle = 'transparent';
                context.fillRect(0, 0, 64, 64);
                context.drawImage(img, 0, 0, 64, 64);
                
                return new THREE.CanvasTexture(canvas);
            }
            
            update(deltaTime, playerX, playerZ) {
                if (!this.isAlive) return;
                
                if (this.isDying) {
                    this.updateDeathAnimation(deltaTime);
                    return;
                }
                
                this.lastX = this.x;
                this.lastZ = this.z;
                
                // Анимация
                this.animationTimer += deltaTime;
                if (this.animationTimer > 0.3) {
                    this.animationTimer = 0;
                    this.spriteFrame = (this.spriteFrame + 1) % 2;
                    this.updateSpriteTexture();
                }
                
                // Обновляем кулдауны
                if (this.attackCooldown > 0) this.attackCooldown -= deltaTime;
                if (this.fireballCooldown > 0) this.fireballCooldown -= deltaTime;
                
                this.lastPlayerX = playerX;
                this.lastPlayerZ = playerZ;
                
                const dx = playerX - this.x;
                const dz = playerZ - this.z;
                const distance = Math.sqrt(dx * dx + dz * dz);
                this.lastDistanceToPlayer = distance;
                
                // Телепортация в режиме Onslaught
                if (currentGameMode === 'onslaught' && distance > 70) {
                    this.teleportTimer += deltaTime;
                    if (this.teleportTimer > 20.0) {
                        this.teleportToPlayer();
                        this.teleportTimer = 0;
                    }
                } else {
                    this.teleportTimer = 0;
                }
                
                // Навигация
                this.pathUpdateTimer += deltaTime;
                if (this.pathUpdateTimer > 2.0 || this.path.length === 0 || distance < 5) {
                    this.pathUpdateTimer = 0;
                    this.path = navigationSystem.findPath(this.x, this.z, playerX, playerZ) || [];
                    this.currentPathIndex = 0;
                }
                
                // Движение
                if (this.path.length > 0 && this.currentPathIndex < this.path.length) {
                    const targetNode = this.path[this.currentPathIndex];
                    const targetX = targetNode.x;
                    const targetZ = targetNode.z;
                    
                    const dxToNode = targetX - this.x;
                    const dzToNode = targetZ - this.z;
                    const distanceToNode = Math.sqrt(dxToNode * dxToNode + dzToNode * dzToNode);
                    
                    if (distanceToNode < 1.0) {
                        this.currentPathIndex++;
                    } else {
                        let dirX = dxToNode / distanceToNode;
                        let dirZ = dzToNode / distanceToNode;
                        
                        this.calculateAvoidanceForce();
                        dirX += this.avoidanceForce.x * 0.5;
                        dirZ += this.avoidanceForce.y * 0.5;
                        
                        const dirLength = Math.sqrt(dirX * dirX + dirZ * dirZ);
                        if (dirLength > 0) {
                            dirX /= dirLength;
                            dirZ /= dirLength;
                        }
                        
                        const newX = this.x + dirX * this.speed * deltaTime;
                        const newZ = this.z + dirZ * this.speed * deltaTime;
                        
                        if (!this.checkWallCollision(newX, newZ)) {
                            this.x = newX;
                            this.z = newZ;
                        } else {
                            this.handleWallCollision(dirX, dirZ, deltaTime);
                        }
                    }
                } else {
                    if (distance > 0) {
                        let dirX = dx / distance;
                        let dirZ = dz / distance;
                        
                        this.calculateAvoidanceForce();
                        dirX += this.avoidanceForce.x * 0.3;
                        dirZ += this.avoidanceForce.y * 0.3;
                        
                        const dirLength = Math.sqrt(dirX * dirX + dirZ * dirZ);
                        if (dirLength > 0) {
                            dirX /= dirLength;
                            dirZ /= dirLength;
                        }
                        
                        const newX = this.x + dirX * this.speed * deltaTime;
                        const newZ = this.z + dirZ * this.speed * deltaTime;
                        
                        if (!this.checkWallCollision(newX, newZ)) {
                            this.x = newX;
                            this.z = newZ;
                        } else {
                            this.handleWallCollision(dirX, dirZ, deltaTime);
                        }
                    }
                }
                
                this.sprite.position.set(this.x, 0.8, this.z);
                this.sprite.lookAt(camera.position);
                
                const movedDistance = Math.sqrt(
                    (this.x - this.lastX) * (this.x - this.lastX) + 
                    (this.z - this.lastZ) * (this.z - this.lastZ)
                );
                
                if (movedDistance < 0.1 * deltaTime) {
                    this.stuckTimer += deltaTime;
                    if (this.stuckTimer > 2.0) {
                        this.findAlternativePath();
                        this.stuckTimer = 0;
                    }
                } else {
                    this.stuckTimer = 0;
                }
                
                // Атаки
                if (distance < this.attackRange && this.attackCooldown <= 0) {
                    this.meleeAttack();
                    this.attackCooldown = 1.0;
                }
                
                if (distance < 15 && this.fireballCooldown <= 0 && distance > this.attackRange) {
                    this.throwFireball(playerX, playerZ);
                    this.fireballCooldown = 5.0;
                }

                // Синхронизация в мультиплеере
                if (multiplayer.isHost && multiplayer.connected) {
                    multiplayer.sendEnemyUpdate(this);
                }
            }
            
            teleportToPlayer() {
                const playerMazeX = Math.round((camera.position.x / CELL_SIZE) + maze[0].length/2);
                const playerMazeZ = Math.round((camera.position.z / CELL_SIZE) + maze.length/2);
                
                let freeCells = [];
                const searchRadius = 5;
                
                for (let z = playerMazeZ - searchRadius; z <= playerMazeZ + searchRadius; z++) {
                    for (let x = playerMazeX - searchRadius; x <= playerMazeX + searchRadius; x++) {
                        if (z >= 0 && z < maze.length && x >= 0 && x < maze[0].length) {
                            if (maze[z][x] === 0) {
                                const worldX = (x - maze[0].length/2) * CELL_SIZE;
                                const worldZ = (z - maze.length/2) * CELL_SIZE;
                                const distanceToPlayer = Math.sqrt(
                                    (worldX - camera.position.x) * (worldX - camera.position.x) + 
                                    (worldZ - camera.position.z) * (worldZ - camera.position.z)
                                );
                                
                                if (distanceToPlayer > 20 && distanceToPlayer < 30) {
                                    freeCells.push({x: worldX, z: worldZ});
                                }
                            }
                        }
                    }
                }
                
                if (freeCells.length > 0) {
                    const randomCell = freeCells[Math.floor(Math.random() * freeCells.length)];
                    this.x = randomCell.x;
                    this.z = randomCell.z;
                    this.sprite.position.set(this.x, 0.8, this.z);
                    this.path = [];
                }
            }
            
            calculateAvoidanceForce() {
                this.avoidanceForce.set(0, 0);
                const avoidanceRadius = 3.0;
                
                for (let enemy of enemies) {
                    if (enemy === this || !enemy.isAlive) continue;
                    
                    const dx = enemy.x - this.x;
                    const dz = enemy.z - this.z;
                    const distance = Math.sqrt(dx * dx + dz * dz);
                    
                    if (distance < avoidanceRadius && distance > 0) {
                        const force = (avoidanceRadius - distance) / avoidanceRadius;
                        this.avoidanceForce.x -= (dx / distance) * force;
                        this.avoidanceForce.y -= (dz / distance) * force;
                    }
                }
            }
            
            handleWallCollision(dirX, dirZ, deltaTime) {
                const directions = [
                    [dirZ, -dirX],
                    [-dirZ, dirX],
                    [dirX * 0.7, dirZ * 0.7],
                    [-dirX * 0.5, -dirZ * 0.5]
                ];
                
                for (let [testX, testZ] of directions) {
                    const newX = this.x + testX * this.speed * deltaTime;
                    const newZ = this.z + testZ * this.speed * deltaTime;
                    
                    if (!this.checkWallCollision(newX, newZ)) {
                        this.x = newX;
                        this.z = newZ;
                        return;
                    }
                }
            }
            
            findAlternativePath() {
                this.path = [];
                this.pathUpdateTimer = 2.0;
            }
            
            checkWallCollision(x, z) {
                const enemyRadius = 0.5;
                const points = [
                    [x - enemyRadius, z],
                    [x + enemyRadius, z],
                    [x, z - enemyRadius],
                    [x, z + enemyRadius]
                ];
                
                for (let [px, pz] of points) {
                    const mazeX = Math.round((px / CELL_SIZE) + maze[0].length/2);
                    const mazeZ = Math.round((pz / CELL_SIZE) + maze.length/2);
                    
                    if (mazeZ >= 0 && mazeZ < maze.length && 
                        mazeX >= 0 && mazeX < maze[0].length) {
                        if (maze[mazeZ][mazeX] === 1) {
                            return true;
                        }
                    } else {
                        return true;
                    }
                }
                
                return false;
            }
            
            meleeAttack() {
                const dx = this.lastPlayerX - this.x;
                const dz = this.lastPlayerZ - this.z;
                const distance = Math.sqrt(dx * dx + dz * dz);
                
                if (distance < this.attackRange) {
                    takeDamage(10);
                }
            }
            
            throwFireball(playerX, playerZ) {
                const fireball = new Fireball(this.x, this.z, playerX, playerZ);
                fireballs.push(fireball);
            }
            
            updateSpriteTexture() {
                const frame = this.spriteFrame + 1;
                const img = new Image();
                img.src = `GameUi/Enemy/Imp/Front/${frame}.png`;
                
                img.onload = () => {
                    const canvas = document.createElement('canvas');
                    canvas.width = 64;
                    canvas.height = 64;
                    const context = canvas.getContext('2d');
                    context.fillStyle = 'transparent';
                    context.fillRect(0, 0, 64, 64);
                    context.drawImage(img, 0, 0, 64, 64);
                    
                    this.sprite.material.map = new THREE.CanvasTexture(canvas);
                    this.sprite.material.needsUpdate = true;
                };
            }
            
            takeDamage(amount, distance) {
                let damage = 0;
                
                if (distance < 4) {
                    damage = 3;
                } else if (distance < 10) {
                    damage = 2;
                } else {
                    damage = 1;
                }
                
                this.health -= damage;
                
                if (Math.random() > 0.5) {
                    if (impDamageSound1) {
                        impDamageSound1.currentTime = 0;
                        impDamageSound1.play();
                    }
                } else {
                    if (impDamageSound2) {
                        impDamageSound2.currentTime = 0;
                        impDamageSound2.play();
                    }
                }
                
                if (this.health <= 0 && !this.isDying) {
                    this.startDeath();
                }
            }
            
            startDeath() {
                this.isDying = true;
                this.deathFrame = 1;
                this.deathTimer = 0;
                
                const deathSounds = [impDeathSound1, impDeathSound2, impDeathSound3];
                const randomSound = deathSounds[Math.floor(Math.random() * deathSounds.length)];
                
                if (randomSound) {
                    randomSound.currentTime = 0;
                    randomSound.play();
                }
                
                this.updateDeathTexture();
            }
            
            updateDeathAnimation(deltaTime) {
                this.deathTimer += deltaTime;
                
                if (this.deathTimer > 0.2) {
                    this.deathTimer = 0;
                    this.deathFrame++;
                    
                    if (this.deathFrame <= 3) {
                        this.updateDeathTexture();
                    } else {
                        this.finalizeDeath();
                    }
                }
            }
            
            updateDeathTexture() {
                const img = new Image();
                img.src = `GameUi/Enemy/Imp/Front/Die${this.deathFrame}.png`;
                
                img.onload = () => {
                    const canvas = document.createElement('canvas');
                    canvas.width = 64;
                    canvas.height = 64;
                    const context = canvas.getContext('2d');
                    context.fillStyle = 'transparent';
                    context.fillRect(0, 0, 64, 64);
                    context.drawImage(img, 0, 0, 64, 64);
                    
                    this.sprite.material.map = new THREE.CanvasTexture(canvas);
                    this.sprite.material.needsUpdate = true;
                };
            }
            
            finalizeDeath() {
                this.isAlive = false;
                scene.remove(this.sprite);
                
                const index = enemies.indexOf(this);
                if (index > -1) {
                    enemies.splice(index, 1);
                }
                
                enemiesKilled++;
                updateUI();
                
                if (currentGameMode === 'extermination' && enemiesKilled >= targetEnemies) {
                    victory();
                }
                
                if (currentGameMode === 'onslaught') {
                    waveEnemiesKilled++;
                    if (waveEnemiesKilled >= waveEnemiesCount && enemies.length === 0) {
                        nextWave();
                    }
                }
            }
        }

        // КЛАСС ФАЙРБОЛА
        class Fireball {
            constructor(x, z, targetX, targetZ) {
                this.x = x;
                this.z = z;
                this.speed = 12.0;
                this.isActive = true;
                this.damage = Math.round((20 + Math.random() * 20) / 5) * 5;
                
                const dx = targetX - x;
                const dz = targetZ - z;
                const distance = Math.sqrt(dx * dx + dz * dz);
                this.dirX = dx / distance;
                this.dirZ = dz / distance;
                
                this.sprite = new THREE.Sprite(new THREE.SpriteMaterial({
                    map: textureLoader.load('GameUi/Enemy/Imp/Fireball.png'),
                    transparent: true,
                    fog: true
                }));
                
                this.sprite.position.set(this.x, 0.8, this.z);
                this.sprite.scale.set(3.5, 3.5, 1);
                scene.add(this.sprite);
                
                this.rotation = 0;
            }
            
            update(deltaTime) {
                if (!this.isActive) return;
                
                this.x += this.dirX * this.speed * deltaTime;
                this.z += this.dirZ * this.speed * deltaTime;
                
                this.sprite.position.set(this.x, 0.8, this.z);
                
                this.rotation += 15 * deltaTime;
                this.sprite.rotation.z = this.rotation;
                
                if (this.checkWallCollision()) {
                    this.destroy();
                    return;
                }
                
                const dx = this.x - camera.position.x;
                const dz = this.z - camera.position.z;
                const distance = Math.sqrt(dx * dx + dz * dz);
                
                if (distance < 2.0) {
                    this.destroy();
                    takeDamage(this.damage);
                }
            }
            
            checkWallCollision() {
                const fireballRadius = 0.8;
                const points = [
                    [this.x - fireballRadius, this.z],
                    [this.x + fireballRadius, this.z],
                    [this.x, this.z - fireballRadius],
                    [this.x, this.z + fireballRadius]
                ];
                
                for (let [px, pz] of points) {
                    const mazeX = Math.round((px / CELL_SIZE) + maze[0].length/2);
                    const mazeZ = Math.round((pz / CELL_SIZE) + maze.length/2);
                    
                    if (mazeZ >= 0 && mazeZ < maze.length && 
                        mazeX >= 0 && mazeX < maze[0].length) {
                        if (maze[mazeZ][mazeX] === 1) {
                            return true;
                        }
                    } else {
                        return true;
                    }
                }
                
                return false;
            }
            
            destroy() {
                this.isActive = false;
                scene.remove(this.sprite);
                
                const index = fireballs.indexOf(this);
                if (index > -1) {
                    fireballs.splice(index, 1);
                }
            }
        }

        // Массивы для врагов и файрболов
        let enemies = [];
        let fireballs = [];

        // Функция создания врагов
        function createEnemies(count, mode = 'normal') {
            for (let i = 0; i < count; i++) {
                let freeCells = [];
                
                for (let y = 1; y < maze.length - 1; y++) {
                    for (let x = 1; x < maze[y].length - 1; x++) {
                        if (maze[y][x] === 0) {
                            const worldX = (x - maze[0].length/2) * CELL_SIZE;
                            const worldZ = (y - maze.length/2) * CELL_SIZE;
                            const dx = worldX - camera.position.x;
                            const dz = worldZ - camera.position.z;
                            const distance = Math.sqrt(dx * dx + dz * dz);
                            
                            if (mode === 'onslaught' || mode === 'extermination') {
                                if (distance > 8 && distance < 20) {
                                    freeCells.push({x: worldX, z: worldZ});
                                }
                            } else if (mode === 'straight') {
                                if (distance > 5) {
                                    freeCells.push({x: worldX, z: worldZ});
                                }
                            }
                        }
                    }
                }
                
                if (freeCells.length > 0) {
                    const randomCell = freeCells[Math.floor(Math.random() * freeCells.length)];
                    enemies.push(new Enemy(randomCell.x, randomCell.z));
                }
            }
        }

        // Функция получения урона игроком
        function takeDamage(amount) {
            const roundedDamage = Math.round(amount);
            hp -= roundedDamage;
            if (hp < 0) hp = 0;
            
            updateUI();
            
            if (playerHitSound) {
                playerHitSound.currentTime = 0;
                playerHitSound.play();
            }
            
            showDamageEffect();
            
            // Отправляем информацию об уроне в мультиплеере
            multiplayer.sendDamage(roundedDamage);
            
            if (hp <= 0) {
                gameOver();
            }
        }

        function showDamageEffect() {
            const damageEffect = document.getElementById('damageEffect');
            damageEffect.style.display = 'block';
            damageEffect.style.opacity = '0.7';
            
            setTimeout(() => {
                damageEffect.style.opacity = '0';
                setTimeout(() => {
                    damageEffect.style.display = 'none';
                }, 300);
            }, 300);
        }

        function gameOver() {
            alert('Игра окончена! Вы погибли.');
            location.reload();
        }

        function victory() {
            alert(`Поздравляем! Вы победили в режиме ${getModeName(currentGameMode)}!`);
            location.reload();
        }

        function getModeName(mode) {
            switch(mode) {
                case 'extermination': return 'Extermination Protocol';
                case 'straight': return 'Straight Through';
                case 'onslaught': return 'Onslaught';
                default: return 'Unknown';
            }
        }

        // Функция проверки попадания по врагам
        function checkEnemyHit() {
            const raycaster = new THREE.Raycaster();
            raycaster.setFromCamera(new THREE.Vector2(0, 0), camera);
            raycaster.far = 50;
            
            for (let enemy of enemies) {
                if (!enemy.isAlive) continue;
                
                const enemySphere = new THREE.Sphere(
                    new THREE.Vector3(enemy.x, 0.8, enemy.z),
                    2.0
                );
                
                if (raycaster.ray.intersectsSphere(enemySphere)) {
                    const dx = enemy.x - camera.position.x;
                    const dz = enemy.z - camera.position.z;
                    const distance = Math.sqrt(dx * dx + dz * dz);
                    
                    enemy.takeDamage(1, distance);
                    return true;
                }
            }
            
            return false;
        }

        // Система волн для режима Onslaught
        function startWave(waveNumber) {
            currentWave = waveNumber;
            waveEnemiesKilled = 0;
            
            if (waveNumber === 1) {
                waveEnemiesCount = 2;
            } else if (waveNumber === 2) {
                waveEnemiesCount = 4;
            } else if (waveNumber === 3) {
                waveEnemiesCount = 6;
            } else {
                waveEnemiesCount = 5 + waveNumber * 2;
            }
            
            enemiesToSpawn = waveEnemiesCount;
            lastSpawnTime = 0;
            
            const waveInfo = document.getElementById('waveInfo');
            waveInfo.textContent = `Волна ${waveNumber}`;
            waveInfo.style.display = 'block';
            
            setTimeout(() => {
                waveInfo.style.display = 'none';
            }, 2000);
            
            updateUI();
        }

        function nextWave() {
            currentWave++;
            startWave(currentWave);
        }

        // Функция постепенного спавна врагов в режиме Onslaught
        function spawnEnemiesOverTime(currentTime) {
            if (currentGameMode !== 'onslaught' || enemiesToSpawn <= 0) return;
            
            if (currentTime - lastSpawnTime > SPAWN_INTERVAL) {
                const spawnCount = Math.min(1, enemiesToSpawn);
                
                let freeCells = [];
                for (let y = 1; y < maze.length - 1; y++) {
                    for (let x = 1; x < maze[y].length - 1; x++) {
                        if (maze[y][x] === 0) {
                            const worldX = (x - maze[0].length/2) * CELL_SIZE;
                            const worldZ = (y - maze.length/2) * CELL_SIZE;
                            const dx = worldX - camera.position.x;
                            const dz = worldZ - camera.position.z;
                            const distance = Math.sqrt(dx * dx + dz * dz);
                            
                            if (distance > 8 && distance < 20) {
                                freeCells.push({x: worldX, z: worldZ});
                            }
                        }
                    }
                }
                
                if (freeCells.length > 0) {
                    for (let i = 0; i < spawnCount; i++) {
                        const randomCell = freeCells[Math.floor(Math.random() * freeCells.length)];
                        enemies.push(new Enemy(randomCell.x, randomCell.z));
                        enemiesToSpawn--;
                    }
                }
                
                lastSpawnTime = currentTime;
            }
        }

        // Анимация с delta time
        const BASE_MOVE_SPEED = 15.0;
        
        function animate(currentTime) {
            requestAnimationFrame(animate);
            
            const deltaTime = Math.min((currentTime - lastTime) / 1000, 0.1);
            lastTime = currentTime;
            
            frameCount++;
            if (currentTime > lastTime + 1000) {
                fps = Math.round((frameCount * 1000) / (currentTime - lastTime));
                frameCount = 0;
                lastTime = currentTime;
                fpsCounter.textContent = `FPS: ${fps}`;
            }
            
            camera.rotation.order = 'YXZ';
            camera.rotation.y = yaw;
            camera.rotation.x = pitch;
            
            const direction = new THREE.Vector3();
            
            const actualMoveSpeed = BASE_MOVE_SPEED * deltaTime;
            
            if (moveForward) direction.z -= actualMoveSpeed;
            if (moveBackward) direction.z += actualMoveSpeed;
            if (moveLeft) direction.x -= actualMoveSpeed;
            if (moveRight) direction.x += actualMoveSpeed;
            
            direction.applyEuler(new THREE.Euler(0, yaw, 0));
            
            let newX = camera.position.x;
            let newZ = camera.position.z;
            
            if (!checkCollision(newX + direction.x, newZ)) {
                newX += direction.x;
            }
            if (!checkCollision(newX, newZ + direction.z)) {
                newZ += direction.z;
            }
            
            camera.position.x = newX;
            camera.position.z = newZ;
            
            // Постепенный спавн врагов в режиме Onslaught
            if (currentGameMode === 'onslaught') {
                spawnEnemiesOverTime(currentTime);
            }
            
            // Обновляем врагов
            for (let enemy of enemies) {
                enemy.update(deltaTime, camera.position.x, camera.position.z);
            }
            
            // Обновляем файрболы
            for (let i = fireballs.length - 1; i >= 0; i--) {
                fireballs[i].update(deltaTime);
            }

            // Обновляем мультиплеер
            if (multiplayer.connected) {
                multiplayer.sendPlayerUpdate();
                multiplayer.sendGameState();
                multiplayer.updateRemotePlayers(deltaTime);
            }
            
            renderer.render(scene, camera);
        }
        
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        // Функция запуска игры
        async function startGame(isMultiplayer = false, roomCode = null) {
            document.getElementById('startMenu').style.display = 'none';
            document.getElementById('optionsMenu').style.display = 'none';
            document.getElementById('modeSelectMenu').style.display = 'none';
            document.getElementById('connectMenu').style.display = 'none';
            
            fpsCounter.style.display = 'block';
            document.getElementById('uiPanel').style.display = 'block';
            document.getElementById('modeStats').style.display = 'block';
            document.getElementById('damageEffect').style.display = 'none';
            
            if (isMultiplayer) {
                document.getElementById('multiplayerInfo').style.display = 'block';
                document.getElementById('roomCodeDisplay').style.display = 'block';
                document.getElementById('roomCodeDisplay').textContent = `КОД: ${roomCode}`;
                
                // Инициализируем мультиплеер
                await multiplayer.init();
                
                if (multiplayer.isHost) {
                    await multiplayer.createRoom();
                    document.getElementById('roomCodeDisplay').textContent = `КОД: ${multiplayer.roomCode}`;
                }
            }
            
            if ('ontouchstart' in window || navigator.maxTouchPoints) {
                document.getElementById('mobileControls').style.display = 'block';
            }
            
            weapon.style.display = 'block';
            
            // СБРОС СОСТОЯНИЯ ОРУЖИЯ ПРИ СТАРТЕ ИГРЫ
            ammo = maxAmmo;
            isShooting = false;
            isReloading = false;
            canShoot = true;
            weapon.src = gunImages.normal;
            isMouseDown = false;
            stopAutoShoot();
            
            // Сбрасываем статистику
            enemiesKilled = 0;
            currentWave = 1;
            
            // Создаем врагов в зависимости от режима
            if (currentGameMode === 'extermination') {
                createEnemies(40, 'extermination');
            } else if (currentGameMode === 'onslaught') {
                startWave(1);
            } else if (currentGameMode === 'straight') {
                createEnemies(15, 'straight');
            }
            
            updateUI();
            
            lastTime = performance.now();
            animate(performance.now());
        }

        // Функции для меню
        function showModeSelect() {
            document.getElementById('startMenu').style.display = 'none';
            document.getElementById('modeSelectMenu').style.display = 'flex';
        }

        function showConnectMenu() {
            document.getElementById('startMenu').style.display = 'none';
            document.getElementById('connectMenu').style.display = 'flex';
        }

        function showOptions() {
            document.getElementById('startMenu').style.display = 'none';
            document.getElementById('optionsMenu').style.display = 'flex';
            
            document.getElementById('musicVolumeSlider').value = settingsManager.musicVolume;
            document.getElementById('soundVolumeSlider').value = settingsManager.soundVolume;
            document.getElementById('sensitivitySlider').value = settingsManager.sensitivity;
        }

        function hideOptions() {
            document.getElementById('optionsMenu').style.display = 'none';
            document.getElementById('startMenu').style.display = 'flex';
        }

        function hideModeSelect() {
            document.getElementById('modeSelectMenu').style.display = 'none';
            document.getElementById('startMenu').style.display = 'flex';
        }

        function hideConnectMenu() {
            document.getElementById('connectMenu').style.display = 'none';
            document.getElementById('startMenu').style.display = 'flex';
        }

        // Инициализация карусели режимов
        function initModeCarousel() {
            const slides = document.querySelectorAll('.mode-slide');
            const prevBtn = document.getElementById('prevMode');
            const nextBtn = document.getElementById('nextMode');
            const startBtn = document.getElementById('startModeButton');
            
            let currentSlide = 0;
            
            updateSlides();
            
            prevBtn.addEventListener('click', () => {
                currentSlide = (currentSlide - 1 + slides.length) % slides.length;
                updateSlides();
            });
            
            nextBtn.addEventListener('click', () => {
                currentSlide = (currentSlide + 1) % slides.length;
                updateSlides();
            });
            
            startBtn.addEventListener('click', () => {
                const activeSlide = document.querySelector('.mode-slide.active');
                const mode = activeSlide.getAttribute('data-mode');
                selectGameMode(mode, false);
            });
            
            function updateSlides() {
                slides.forEach((slide, index) => {
                    slide.classList.remove('active', 'left', 'right');
                    
                    if (index === currentSlide) {
                        slide.classList.add('active');
                    } else if (index === (currentSlide - 1 + slides.length) % slides.length) {
                        slide.classList.add('left');
                    } else if (index === (currentSlide + 1) % slides.length) {
                        slide.classList.add('right');
                    }
                });
            }
            
            // Добавляем поддержку свайпов
            let touchStartX = 0;
            let touchEndX = 0;
            
            const carousel = document.querySelector('.mode-carousel');
            
            carousel.addEventListener('touchstart', (e) => {
                touchStartX = e.changedTouches[0].screenX;
            });
            
            carousel.addEventListener('touchend', (e) => {
                touchEndX = e.changedTouches[0].screenX;
                handleSwipe();
            });
            
            function handleSwipe() {
                const swipeThreshold = 50;
                
                if (touchEndX < touchStartX - swipeThreshold) {
                    currentSlide = (currentSlide + 1) % slides.length;
                    updateSlides();
                } else if (touchEndX > touchStartX + swipeThreshold) {
                    currentSlide = (currentSlide - 1 + slides.length) % slides.length;
                    updateSlides();
                }
            }
        }

        // Функция выбора режима игры
        function selectGameMode(mode, isMultiplayer = false, roomCode = null) {
            currentGameMode = mode;
            
            mazeGen = new MazeGenerator(25, 25, mode);
            maze = mazeGen.getMaze();
            
            navigationSystem = new NavigationSystem();
            
            startPos = findRandomStartPosition();
            camera.position.set(startPos.x, 1.7, startPos.z);
            
            const materials = createMaterials();
            createScene(materials);
            
            startGame(isMultiplayer, roomCode);
        }

        // Инициализация меню
        function initMenu() {
            const playButton = document.getElementById('playButton');
            const connectButton = document.getElementById('connectButton');
            const optionsButton = document.getElementById('optionsButton');
            const backButton = document.getElementById('backButton');
            const backToMainButton = document.getElementById('backToMainButton');
            const backFromConnectButton = document.getElementById('backFromConnectButton');
            const joinRoomButton = document.getElementById('joinRoomButton');
            const roomCodeInput = document.getElementById('roomCodeInput');
            
            document.getElementById('musicVolumeSlider').value = settingsManager.musicVolume;
            document.getElementById('soundVolumeSlider').value = settingsManager.soundVolume;
            document.getElementById('sensitivitySlider').value = settingsManager.sensitivity;
            
            startMusic();
            document.addEventListener('click', startMusicOnInteraction, { once: true });
            document.addEventListener('touchstart', startMusicOnInteraction, { once: true });
            
            playButton.addEventListener('click', function(e) {
                showModeSelect();
            });
            
            connectButton.addEventListener('click', function(e) {
                showConnectMenu();
            });
            
            optionsButton.addEventListener('click', function(e) {
                showOptions();
            });
            
            backButton.addEventListener('click', function(e) {
                hideOptions();
            });
            
            backToMainButton.addEventListener('click', function(e) {
                hideModeSelect();
            });
            
            backFromConnectButton.addEventListener('click', function(e) {
                hideConnectMenu();
            });
            
            joinRoomButton.addEventListener('click', async function(e) {
                const roomCode = roomCodeInput.value.trim();
                if (roomCode.length === 6) {
                    const success = await multiplayer.joinRoom(roomCode);
                    if (success) {
                        selectGameMode('extermination', true, roomCode);
                    } else {
                        alert('Не удалось подключиться к комнате. Проверьте код.');
                    }
                } else {
                    alert('Введите 6-символьный код комнаты');
                }
            });
            
            initModeCarousel();
        }

        // Настройки
        document.getElementById('sensitivitySlider').addEventListener('input', function(e) {
            const sensitivity = parseInt(e.target.value);
            mouseSensitivity = sensitivity * 0.0004;
            settingsManager.updateSetting('sensitivity', sensitivity);
        });

        document.getElementById('musicVolumeSlider').addEventListener('input', function(e) {
            const volume = parseInt(e.target.value);
            musicVolume = volume / 100;
            settingsManager.updateSetting('musicVolume', volume);
            updateVolumes();
        });

        document.getElementById('soundVolumeSlider').addEventListener('input', function(e) {
            const volume = parseInt(e.target.value);
            soundVolume = volume / 100;
            settingsManager.updateSetting('soundVolume', volume);
            updateVolumes();
        });

        // Запуск игры
        loadTextures().then(() => {
            mazeGen = new MazeGenerator(25, 25);
            maze = mazeGen.getMaze();
            navigationSystem = new NavigationSystem();
            
            const materials = createMaterials();
            createScene(materials);
            initAudio();
            initControls();
            initMenu();
            weapon.style.display = 'none';
            
            preloadWeaponImages();
        }).catch((error) => {
            console.error('Ошибка загрузки:', error);
            mazeGen = new MazeGenerator(25, 25);
            maze = mazeGen.getMaze();
            navigationSystem = new NavigationSystem();
            
            const materials = createMaterials();
            createScene(materials);
            initAudio();
            initControls();
            initMenu();
            weapon.style.display = 'none';
            
            preloadWeaponImages();
        });
    </script>
</body>
</html>
